<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UBuntu 16.04 RTAI实时系统环境安装配置</title>
      <link href="/2022/09/27/rtai-realtime/"/>
      <url>/2022/09/27/rtai-realtime/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="UBuntu-16-04-RTAI实时系统环境安装配置"><a href="#UBuntu-16-04-RTAI实时系统环境安装配置" class="headerlink" title="UBuntu 16.04 RTAI实时系统环境安装配置"></a>UBuntu 16.04 RTAI实时系统环境安装配置</h2><blockquote><p>针对ubuntu 系统实时性改造先前已进行说明，此处不再赘述。此次是针对RTAI内核进行编译测试，RTAI作为3大开源linux软实时内核，其性能要高于Preempt-rt,但由于并非随linux主线内核更新，所以存在一定滞后，庆幸的是RTAI也一直在维护，相比xenomai更有优势。RTAI最新版本更新于2021年5月(RTAI-5.3),保守起见此次选用RTAI-5.1版本进行安装测试。考虑到系统层面对实时影响，推荐使用低版本系统，不过本次安装配置流程已在UBuntu18.04上测试通过，且编译运行正常。</p></blockquote><p>【系统环境】：</p><ul><li>操作系统：ubuntu16.04/ubuntu18.04</li><li>Kernel: Linux-4.9.80</li><li>Path : RTAI-5.1</li></ul><p> [TOC]</p><h3 id="1-下载ubuntu-4-9-80内核补丁链接"><a href="#1-下载ubuntu-4-9-80内核补丁链接" class="headerlink" title="1.下载ubuntu 4.9.80内核补丁链接"></a>1.下载ubuntu 4.9.80内核补丁<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.80/">链接</a></h3><p>  0001-base-packaging.patch<br>  0002-UBUNTU-SAUCE-add-vmlinux.strip-to-BOOT_TARGETS1-on-p.patch<br>  0003-UBUNTU-SAUCE-tools-hv-lsvmbus-add-manual-page.patch<br>  0004-UBUNTU-SAUCE-no-up-disable-pie-when-gcc-has-it-enabl.patch<br>  0005-dh_builddeb-switch-to-Zgzip-to-avoid-dpkg-bug-on-lar.patch<br>  0006-debian-changelog.patch<br>  0007-configs-based-on-Ubuntu-4.9.0-11.12.patch<br>  linux-image-4.9.80-040980-generic_4.9.80-040980.201802031730_amd64.deb</p><h3 id="2-下载linux-4-9-80内核文件链接"><a href="#2-下载linux-4-9-80内核文件链接" class="headerlink" title="2.下载linux-4.9.80内核文件链接"></a>2.下载linux-4.9.80内核文件<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/">链接</a></h3><p>  linux-4.9.80.tar.gz  </p><h3 id="3-下载RTAI-5-1源码链接"><a href="#3-下载RTAI-5-1源码链接" class="headerlink" title="3.下载RTAI-5.1源码链接"></a>3.下载RTAI-5.1源码<a href="https://www.rtai.org/">链接</a></h3><p>   tar Jxf rtai-5.1.tar.bz2</p><h3 id="4-通用内核打补丁"><a href="#4-通用内核打补丁" class="headerlink" title="4.通用内核打补丁"></a>4.通用内核打补丁</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.9.80/</span><br><span class="line">patch -p1 &lt; ../0001-base-packaging.patch</span><br><span class="line">patch -p1 &lt; ../0002-UBUNTU-SAUCE-add-vmlinux.strip-to-BOOT_TARGETS1-on-p.patch</span><br><span class="line">patch -p1 &lt; ../0003-UBUNTU-SAUCE-tools-hv-lsvmbus-add-manual-page.patch</span><br><span class="line">patch -p1 &lt; ../0004-UBUNTU-SAUCE-no-up-disable-pie-when-gcc-has-it-enabl.patch</span><br><span class="line">patch -p1 &lt; ../0005-dh_builddeb-switch-to-Zgzip-to-avoid-dpkg-bug-on-lar.patch</span><br><span class="line">patch -p1 &lt; ../0006-debian-changelog.patch</span><br><span class="line">patch -p1 &lt; ../0007-configs-based-on-Ubuntu-4.9.0-11.12.patch</span><br><span class="line">//打rtai实时补丁</span><br><span class="line">patch -p1 &lt; ../rtai-5.1/base/arch/x86/patches/hal-linux-4.9.80-x86-4.patch</span><br></pre></td></tr></table></figure><h3 id="5-获取通用内核-config配置文件，以此为配置项基础，进行内核修改裁减"><a href="#5-获取通用内核-config配置文件，以此为配置项基础，进行内核修改裁减" class="headerlink" title="5.获取通用内核.config配置文件，以此为配置项基础，进行内核修改裁减."></a>5.获取通用内核.config配置文件，以此为配置项基础，进行内核修改裁减.</h3><pre><code>//返回上一层目录cd ../dpkg -x linux-image-4.9.80-040980-generic_4.9.80-040980.201802031730_amd64.deb ./configs//拷贝系统配置文件到linux-4.9.80内核源码目录下cp ./configs/boot/config-4.9.80-040980-generic ./linux-4.9.80/.config   </code></pre><blockquote><p>按照rtai-5.1/README.CONF_RMRKS文档内容要把CONFIG_AUDITSYSCALL改成no,但与v4.4.115内核不同的是v4.9.80中CONFIG_AUDITSYSCALL变量被改成无法修改了,所以要改动一下:<br>打开v4.9.80/init/Kconfig找到</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config AUDITSYSCALL</span><br><span class="line">def_bool y</span><br><span class="line">depends on AUDIT &amp;&amp; HAVE_ARCH_AUDITSYSCALL</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config AUDITSYSCALL</span><br><span class="line">bool <span class="string">&quot;Enable system-call auditing support&quot;</span></span><br><span class="line">depends on AUDIT &amp;&amp; HAVE_ARCH_AUDITSYSCALL</span><br><span class="line">default y <span class="keyword">if</span> SECURITY_SELINUX</span><br><span class="line"><span class="built_in">help</span></span><br><span class="line">  Enable low-overhead system-call auditing infrastructure that</span><br><span class="line">  can be used independently or with another kernel subsystem,</span><br><span class="line">  such as SELinux.</span><br></pre></td></tr></table></figure><h3 id="6-配置内核"><a href="#6-配置内核" class="headerlink" title="6.配置内核"></a>6.配置内核</h3><blockquote><p>For making the Linux kernel work with RTAI you should check the following settings in the kernel configuration dialog.<br>This list is updated for RTAI 5.1. For other RTAI versions read /usr/local/src/rtai/README.CONF_RMRKS !</p></blockquote><ul><li><p>“General setup”:</p><ul><li>Disable “Enable sytem-call auditing support” (AUDITSYSCALL)</li><li>Important: set “Stack Protector buffer overflow detection” (at the bottom of the menu) to “Regular(CC_STACKPROTECTOR_REGULAR) - or even “None” (CC_STACKPROTECTOR_NONE) if the latency test crashes.</li></ul></li><li><p>“Procesor type an features”:</p><ul><li>Disable “Support x2apic” if present (X86_X2APIC)<br>Maximum number of CPUs (NR_CPUS), optional, if you want to disable hyperthreading and to reduce the output of RTAI tests in the kernel messages.</li><li>Disable “Multi-core scheduler support” (SCHED_MC) (in order to be able to disable CPU frequency scaling, for kernel &gt;= 4.14)</li><li>Enable “Interrupt pipeline” (IPIPE)</li></ul></li><li><p>“Power management and ACPI options”:</p><ul><li>In “ACPI (Advanced Configuration and Power Interface) Support”:<ul><li>Disable “Processor” (ACPI_PROCESSOR)</li></ul></li><li>Disable “CPU Frequency scaling” (CPU_FREQ) (sometimes you need to disbale this first in order to be able to disable ACPI_PROCESSOR)</li><li>In “CPU Idle”:<ul><li>Disable “CPU idle PM support” (CPU_IDLE)</li></ul></li></ul></li><li><p>“Device Drivers”:</p><ul><li>In “Staging drivers”:<ul><li>Deselect “Data acquisition support (comedi)” (COMEDI)</li></ul></li></ul></li><li><p>“Kernel hacking”:</p><ul><li>   In “Compile-time checks and compiler options”:      - Disable “Compile the kernel with debug info” (DEBUG_INFO) Disabling debugging information makes the kernel much smaller. So unless you know that you need it disable it.</li><li>Disable “Tracers” (FTRACE)</li></ul></li></ul><p>Leave the configuration dialog by pressing “Exit” until you are asked “Save kernel config?”. Select “Yes”.</p><p>Then the new kernel is being compiled - be patient.</p><h3 id="7-编译"><a href="#7-编译" class="headerlink" title="7.编译"></a>7.编译</h3><pre><code>make -j8 LOCALVERSION=-rtai-5.1 deb-pkg</code></pre><h3 id="8-切换到上一层目录安装"><a href="#8-切换到上一层目录安装" class="headerlink" title="8.切换到上一层目录安装"></a>8.切换到上一层目录安装</h3><blockquote><p>cd ../<br>sudo dpkg -i linux-image-4.9.80-rtai-5.1_4.9.80-rtai-5.1-1_amd64.deb<br>sudo dpkg -i linux-headers-4.9.80-rtai-5.1_4.9.80-rtai-5.1-1_amd64.deb<br>sudo reboot　//启动新内核</p></blockquote><h3 id="8-新内核下编译安装rtai用户库及驱动"><a href="#8-新内核下编译安装rtai用户库及驱动" class="headerlink" title="8.新内核下编译安装rtai用户库及驱动"></a>8.新内核下编译安装rtai用户库及驱动</h3><blockquote><p>cd  rtai-5.1<br>make menuconfig</p></blockquote><ul><li>General —&gt;<ul><li>(/opt/rtai-5.1_v4.9.80) Installation directory                                         </li><li>(/usr/src/linux-headers-4.9.80-rtai-5.1+) Linux source tree</li></ul></li><li>Machine –&gt;<ul><li>(4)Number of CPUs(SMP-only)</li></ul></li><li>Add-ons  —&gt;<ul><li>[*] Real-Time Driver Model over RTAI                           </li><li>(128) Number of RTDM file descriptors                          </li><li>[*]   Enable select multiplexing for RTDM services</li></ul></li></ul><blockquote><p>make<br>sudo make install<br>cd /opt/rtai-5.1_v4.9.80/modules<br>sudo insmod rtai_hal.ko<br>sudo insmod rtai_sched.ko  //如果到这儿没死机就说明rtai安装成功了<br>sudo insmod rtai_fifos.ko<br>sudo insmod rtai_sem.ko<br>sudo insmod rtai_shm.ko<br>sudo insmod rtai_rtdm.ko</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> RealTime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04_realsense</title>
      <link href="/2022/09/10/ubuntu18-04-realsence/"/>
      <url>/2022/09/10/ubuntu18-04-realsence/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ubuntu18-04-＋realsence－sdk安装"><a href="#ubuntu18-04-＋realsence－sdk安装" class="headerlink" title="ubuntu18.04 ＋realsence－sdk安装"></a>ubuntu18.04 ＋realsence－sdk安装</h3><p>[toc]</p><p><strong>环境：</strong></p><ul><li> 系统：ubuntu18.04</li><li>工控机：Nodka 工控机(NP-6122)<h4 id="1-更新ubuntu"><a href="#1-更新ubuntu" class="headerlink" title="1. 更新ubuntu:"></a>1. 更新ubuntu:</h4>  <code>sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get dist-upgrade</code><h4 id="2-下载最新的librealsense-SDK"><a href="#2-下载最新的librealsense-SDK" class="headerlink" title="2. 下载最新的librealsense SDK:"></a>2. 下载最新的librealsense SDK:</h4><code>git clone https://github.com/IntelRealSense/librealsense.git</code></li></ul><p><strong>注意：安装时，不要将相机连在电脑上。</strong></p><h4 id="3-安装必要的依赖"><a href="#3-安装必要的依赖" class="headerlink" title="3. 安装必要的依赖"></a>3. 安装必要的依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">sudo apt-get install git libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev </span><br><span class="line">sudo apt-get install libglfw3-dev</span><br></pre></td></tr></table></figure><h4 id="4-安装-librealsense原文件目录下的许可脚本"><a href="#4-安装-librealsense原文件目录下的许可脚本" class="headerlink" title="4. 安装 librealsense原文件目录下的许可脚本"></a>4. 安装 librealsense原文件目录下的许可脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">sudo cp config/99-realsense-libusb.rules /etc/udev/rules.d/ </span><br><span class="line">sudo udevadm control --reload-rules &amp;&amp; udevadm trigger</span><br></pre></td></tr></table></figure><h4 id="5-编译librealsense"><a href="#5-编译librealsense" class="headerlink" title="5. 编译librealsense"></a>5. 编译librealsense</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">cmake ../ -DBUILD_EXAMPLES=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="6-安装librealsense-SDK"><a href="#6-安装librealsense-SDK" class="headerlink" title="6. 安装librealsense-SDK"></a>6. 安装librealsense-SDK</h4><p><code>sudo make uninstall &amp;&amp; make clean &amp;&amp; make &amp;&amp; sudo make install</code></p><h4 id="7-连接相机至电脑USB3-0接口并打开摄像头显示界面"><a href="#7-连接相机至电脑USB3-0接口并打开摄像头显示界面" class="headerlink" title="7. 连接相机至电脑USB3.0接口并打开摄像头显示界面"></a>7. 连接相机至电脑USB3.0接口并打开摄像头显示界面</h4><p><code>realsense-viewer</code><br><strong>注意：连接相机的数据线必须是USB3.0的数据线（USB口内为蓝色）</strong></p><h4 id="8-在界面安装适配的相机Firmware-界面会有提示"><a href="#8-在界面安装适配的相机Firmware-界面会有提示" class="headerlink" title="8. 在界面安装适配的相机Firmware(界面会有提示)"></a>8. 在界面安装适配的相机Firmware(界面会有提示)</h4><hr><h3 id="ubuntu18-04-＋librealsense2-ROS-安装"><a href="#ubuntu18-04-＋librealsense2-ROS-安装" class="headerlink" title="ubuntu18.04 ＋librealsense2-ROS　安装"></a>ubuntu18.04 ＋librealsense2-ROS　安装</h3><h4 id="1-构建ROS工作空间"><a href="#1-构建ROS工作空间" class="headerlink" title="1. 构建ROS工作空间"></a>1. 构建ROS工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p realsense_rosws/src     <span class="comment">#realsense_rows 自己命名的工程文件名，可改,本教程是在home路　　　　　　　　　　　　　　　　　　　　　　　径下建立</span></span><br><span class="line"><span class="built_in">cd</span> realsense_rosws/src           <span class="comment">#回到src文件夹路径下</span></span><br><span class="line">catkin_init_workspace            <span class="comment">#创建工作空间</span></span><br></pre></td></tr></table></figure><h4 id="2-下载realsense-ros"><a href="#2-下载realsense-ros" class="headerlink" title="2. 下载realsense-ros"></a>2. 下载realsense-ros</h4><p><code>git clone https://github.com/IntelRealSense/realsense-ros.git</code></p><h4 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> realsense_rosws    <span class="comment">#返回该文件目录</span></span><br><span class="line">catkin_make clean   </span><br><span class="line">catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">catkin_make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /home/robot/realsense_rosws/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment">#注意修改文件路径</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="4-安装rgbd-launch-包"><a href="#4-安装rgbd-launch-包" class="headerlink" title="4. 安装rgbd-launch 包"></a>4. 安装rgbd-launch 包</h4><p><code>sudo apt-get install ros-melodic-rgbd-launch</code></p><h4 id="5-运行"><a href="#5-运行" class="headerlink" title="5.运行"></a>5.运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore         <span class="comment">#新开一个终端</span></span><br><span class="line">roslaunch realsense2_camera rs_rgbd.launch  <span class="comment">#另新开一个终端</span></span><br><span class="line">rivz         <span class="comment">#另新开一个终端</span></span><br></pre></td></tr></table></figure><h4 id="6-realsense-ros配置"><a href="#6-realsense-ros配置" class="headerlink" title="6. realsense-ros配置"></a>6. realsense-ros配置</h4><ul><li>左上角Displays 中 Fixed Frame 选项中，下拉菜单选择 camera_link</li><li>点击该框中的Add -&gt; 上方点击 By topic -&gt; /depth_registered 下的 /points 下的/PointCloud2</li><li>点击该框中的Add -&gt; 上方点击 By topic -&gt; /color 下的 /image_raw 下的image</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用说明</title>
      <link href="/2022/07/15/light-usr-book/"/>
      <url>/2022/07/15/light-usr-book/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><blockquote><p>小夜灯需要接入网路后才能在苹果<strong>“家庭”</strong>中导入使用，配置前请确保以及具备配置使用环境。</p></blockquote><h5 id="使用环境："><a href="#使用环境：" class="headerlink" title="使用环境："></a>使用环境：</h5><ul><li> 1.具备<strong>2.4G 无线网络</strong>(小夜灯只能连接2.4G频段无线网)。</li><li> 2.有一台苹果设备作为控制中枢（ipad/iPhone）。</li></ul><hr><h4 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤:"></a>配置步骤:</h4><ol><li><p>将设备接入电源，小夜灯通电后进行自检，绿色常亮。<br><img src="./1.jpg" alt="Alt text"></p></li><li><p>首次使用（或wifi变更）需要重置网络，即在接通电源后绿灯亮起时长按壳体正面按钮，等待绿色灯熄灭，红色灯亮起时松开按钮。【后续启动会自动识别连接已配置的网络，只在网络异常时执行此操作】<br><img src="./2.jpg" alt="Alt text"></p><blockquote><p> <strong>注：</strong>后续使用过程中发现出现<strong>“绿色灯常亮-&gt;绿色灯熄灭-&gt;粉红色灯闪烁3次-&gt;绿色常亮”</strong>这种情况时，表面网络也存在问题，需要进行<strong>重置网络配置。</strong><img src="./3.jpg" alt="Alt text"></p></blockquote></li><li><p>红色灯亮起时松开长按的按钮，打开ipad/iPhone手机网络，连接名为”HK”的wifi热点。<br><img src="./4.jpg" alt="Alt text"><br><img src="./5.jpg" alt="Alt text"></p></li><li><p>连接”HK”热点后，会自动跳转到wifi配置页面。<br><img src="./6.jpg" alt="Alt text"><br>点击配置wifi，选择你家里的wifi，并配置密码。<em><strong>（必须是2.4G wifi）</strong></em><br><img src="./7.jpg" alt="Alt text"><br><img src="./8.jpg" alt="Alt text"></p></li><li><p>点击保存等待wifi配置（正常配置需要10s~90s），若配置成功，红色灯会转变为蓝色，否则尝试重复步骤4 或拔掉电源重启启动配置。<br><img src="./9.jpg" alt="Alt text"></p></li><li><p>（首次使用或“家庭”变更需要重置）蓝色灯亮起时，小夜灯等待是否重置<strong>苹果家庭</strong>设备注册信息，若<strong>苹果家庭</strong>存在家庭移除变更，或者想更改小夜灯绑定不同“家庭”时，需要进行“家庭”重置。方法长按正面按钮，知道蓝色灯熄灭。<br><img src="./9.jpg" alt="Alt text"></p></li><li><p>蓝色灯熄灭后，打开ipad/iPhone “家庭” 应用，创建“我的家” 家庭场景，在“我的家”中添加设备。<br><img src="./10.jpg" alt="Alt text"><br>选择扫描出来的设备<br><img src="./11.jpg" alt="Alt text"><br>点击任然添加<br><img src="./12.jpg" alt="Alt text"><br>输入配对密码全为“1”<br><img src="./13.jpg" alt="Alt text"><br>等待配置完成（若是配置失败，重复步骤6或者断电重新启动，重新启动可跳过wifi配置），更具喜好随性设置下。<br><img src="./14.jpg" alt="Alt text"><br><img src="./15.jpg" alt="Alt text"><br><img src="./16.jpg" alt="Alt text"><br><img src="./17.jpg" alt="Alt text"></p></li><li><p>配置完成后，就可以在家庭应用中控制并使用小夜灯了<br><img src="./18.jpg" alt="Alt text"><br><img src="./19.jpg" alt="Alt text"></p></li><li><p>可设置写按钮开关自动化的操作。<br><img src="./20.jpg" alt="Alt text"></p></li><li><p>具体苹果家庭中场景自动化或者一些好玩实用的功能可以自己摸索，小夜灯可以作为自动化场景中控制对象和被控对象进行使用。一些好玩的功能比如：日出关灯，日落亮灯，离家关灯，回家亮灯等等…</p></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> DIY Homekit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>igh_ethercat</title>
      <link href="/2022/07/15/igh-ethercat/"/>
      <url>/2022/07/15/igh-ethercat/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="IGH-Ethercat主站安装配置"><a href="#IGH-Ethercat主站安装配置" class="headerlink" title="IGH Ethercat主站安装配置"></a>IGH Ethercat主站安装配置</h3><blockquote><p>记录在使用安装IGH过程中遇到的问题，目前存在大坑：</p><ul><li>实时内核版本大于5.0的不用试了，别听论坛瞎BB肯定不支持。</li><li>最新源码要通过github下载,其他位置的下载源码有问题！！<br>eg：<del><a href="https://sourceforge.net/projects/etherlabmaster/">https://sourceforge.net/projects/etherlabmaster/</a></del> 大坑</li><li>xenomai实时内核补丁不同版本igh安装会有问题，1.5/1.5.2有坑，没有踩完，推荐还是先prempt安装测试，后续有机会再弄Xenomai</li></ul></blockquote><p>[TOC]</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="1-安装编译工具依赖"><a href="#1-安装编译工具依赖" class="headerlink" title="1.安装编译工具依赖"></a>1.安装编译工具依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf autogen libtool</span><br></pre></td></tr></table></figure><h4 id="2-编译配置IGH源码"><a href="#2-编译配置IGH源码" class="headerlink" title="2.编译配置IGH源码"></a>2.编译配置IGH源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd etherlab ##进入IGH源码包</span><br><span class="line">./bootstrap ##执行配置脚步</span><br><span class="line">## 设置配置项 实时网卡驱动 安装到的内核目录</span><br><span class="line">./configure --enable-cycles --enable-hrtimer --enable-8139too=no --with-linux-dir=/usr/src/linux-headers-4.19.r26/</span><br><span class="line">##编译并安装到内核模块</span><br><span class="line">make -j$(nproc) all modules ##编译内核模块</span><br><span class="line">sudo make modules_install install</span><br></pre></td></tr></table></figure><blockquote><p> <strong>亦可执行下述操作实现IGH内核模块编译安装</strong><br>make #编译用户态的库<br>make modules #编译ethercat驱动<br>sudo make install #安装库文件<br>sudo make modules_install #安装驱动<br>sudo depmod</p></blockquote><h4 id="3-将启动文件添加到系统命令中"><a href="#3-将启动文件添加到系统命令中" class="headerlink" title="3.将启动文件添加到系统命令中"></a>3.将启动文件添加到系统命令中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/sysconfig</span><br><span class="line">## 不同版本IGH安装后的目录不同 /usr/local/ 或 /opt/etherlab 具体情况具体对待</span><br><span class="line">ln -s /usr/local/etc/init.d/ethercat /etc/init.d/ethercat</span><br><span class="line">ln -s /opt/etherlab/etc/init.d/ethercat /etc/init.d/ethercat</span><br></pre></td></tr></table></figure><p>使用 ifconfig命令查询网口mac地址 （68:ed:a6:03:9f:0d ）</p><blockquote><pre><code> ifocnfig    enp1s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500    ether 68:ed:a6:03:9f:0d  txqueuelen 1000  (以太网)    RX packets 0  bytes 0 (0.0 B)    RX errors 0  dropped 0  overruns 0  frame 0    TX packets 0  bytes 0 (0.0 B)    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0    device memory 0xdf200000-df21ffff  </code></pre></blockquote><p>修改/opt/etherlab/etc/sysconfig/ethercat 或 opt/etherlab/etc/ethercat.conf文件<br><strong>注意路径 “/usr/local 或 /opt/etherlab”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MASTER0_DEVICE=&quot;68:ed:a6:03:9f:0d  &quot;  ##引号中的内容换成要作为EtherCAT总线的网卡地址，</span><br><span class="line">DEVICE_MODULES=&quot;generic&quot;   ##引号里面填入 generic</span><br></pre></td></tr></table></figure><p>将修改后的文件进行拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##注意路径 “/usr/local 或 /opt/etherlab&quot;</span><br><span class="line">sudo cp /opt/etherlab/etc/sysconfig/ethercat  /etc/sysconfig/ethercat </span><br><span class="line">sudo cp /opt/etherlab/etc/ethercat.conf /etc</span><br></pre></td></tr></table></figure><h4 id="4-重启系统并测试"><a href="#4-重启系统并测试" class="headerlink" title="4.重启系统并测试"></a>4.重启系统并测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ethercat start</span><br><span class="line">#显示如下</span><br><span class="line">Starting EtherCAT master 1.5.2  done</span><br></pre></td></tr></table></figure><h4 id="5-Ethercat-tool测试"><a href="#5-Ethercat-tool测试" class="headerlink" title="5.Ethercat tool测试"></a>5.Ethercat tool测试</h4><p><strong>ethercat slaves</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0  0:0  PREOP  +  CoolDrive R Series</span><br><span class="line">1  0:1  PREOP  +  CoolDrive R Series</span><br><span class="line">2  0:2  PREOP  +  CoolDrive R Series</span><br><span class="line">3  0:3  PREOP  +  CoolDrive R Series</span><br><span class="line">4  0:4  PREOP  +  CoolDrive R Series</span><br><span class="line">5  0:5  PREOP  +  CoolDrive R Series</span><br></pre></td></tr></table></figure><p><strong>ethercat master</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Master0</span><br><span class="line">  Phase: Idle</span><br><span class="line">  Active: no</span><br><span class="line">  Slaves: 0</span><br><span class="line">  Ethernet devices:</span><br><span class="line">    Main: c4:00:ad:41:ce:72 (attached)</span><br><span class="line">      Link: DOWN</span><br><span class="line">      Tx frames:   0</span><br><span class="line">      Tx bytes:    0</span><br><span class="line">      Rx frames:   0</span><br><span class="line">      Rx bytes:    0</span><br><span class="line">      Tx errors:   0</span><br><span class="line">      Tx frame rate [1/s]:      0      0      0</span><br><span class="line">      Tx rate [KByte/s]:      0.0    0.0    0.0</span><br><span class="line">      Rx frame rate [1/s]:      0      0      0</span><br><span class="line">      Rx rate [KByte/s]:      0.0    0.0    0.0</span><br><span class="line">    Common:</span><br><span class="line">      Tx frames:   0</span><br><span class="line">      Tx bytes:    0</span><br><span class="line">      Rx frames:   0</span><br><span class="line">      Rx bytes:    0</span><br><span class="line">      Lost frames: 0</span><br><span class="line">      Tx frame rate [1/s]:      0      0      0</span><br><span class="line">      Tx rate [KByte/s]:      0.0    0.0    0.0</span><br><span class="line">      Rx frame rate [1/s]:      0      0      0</span><br><span class="line">      Rx rate [KByte/s]:      0.0    0.0    0.0</span><br><span class="line">      Loss rate [1/s]:          0      0      0</span><br><span class="line">      Frame loss [%]:         0.0    0.0    0.0</span><br><span class="line">  Distributed clocks:</span><br><span class="line">    Reference clock:   None</span><br><span class="line">    DC reference time: 0</span><br><span class="line">    Application time:  0</span><br><span class="line">                       2000-01-01 00:00:00.000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ethercat </tag>
            
            <tag> IGH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux_preempt</title>
      <link href="/2022/07/14/linux-preempt/"/>
      <url>/2022/07/14/linux-preempt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="linux实时内核Preempt编译安装"><a href="#linux实时内核Preempt编译安装" class="headerlink" title="linux实时内核Preempt编译安装"></a>linux实时内核Preempt编译安装</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><p>系 统 ： Ubuntu16.04.6<br>内核版本 ： Linux-4.15.0-72<br>目标内核 ： Linux-4.19.72-rt26<br>下载地址 ： <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/">https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/</a> （下载内核）<br><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/projects/rt/">https://mirrors.edge.kernel.org/pub/linux/kernel/projects/rt/</a> （下载补丁）<br>国内镜像 ： <a href="https://mirrors.aliyun.com/linux-kernel/">https://mirrors.aliyun.com/linux-kernel/</a> （内核下载速度快）<br>安装依赖 ：sudo apt-get install -y build-essential kernel-package libncurses5-dev</p><h4 id="2-安装实时补丁"><a href="#2-安装实时补丁" class="headerlink" title="2. 安装实时补丁"></a>2. 安装实时补丁</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">makdir rt_linux_build  <span class="comment">##创建个文件夹用来存放编译所需文件</span></span><br><span class="line"><span class="built_in">cd</span> Download <span class="comment">##进入下载文件保存目录</span></span><br><span class="line">cp linux-4.19.72.tar.xz patch-4.19.72-rt26.patch.xz  ~/rt_linux_build   <span class="comment">##拷贝内核源码和补丁文件</span></span><br><span class="line"><span class="built_in">cd</span>  ~/rt_linux_build/</span><br><span class="line">xz -<span class="built_in">cd</span> linux-4.19.72.tar.xz | tar xvf - <span class="comment">##解压源码</span></span><br><span class="line">xzcat ../patch-4.19.72-rt26.patch.xz   <span class="comment">##解压补丁</span></span><br><span class="line"><span class="built_in">cd</span> linux-4.19.72/ <span class="comment">##进入内核源码目录</span></span><br><span class="line">patch -p1 &lt; ../patch-4.19.72-rt26.patch <span class="comment">##安装补丁</span></span><br></pre></td></tr></table></figure><h4 id="3-拷贝系统通用内核默认内核配置"><a href="#3-拷贝系统通用内核默认内核配置" class="headerlink" title="3. 拷贝系统通用内核默认内核配置"></a>3. 拷贝系统通用内核默认内核配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /boot/config-4.15.0-72-generic  .config</span><br><span class="line"><span class="comment">##安装内核编译一些依赖工具(可能部分工具安装不上，需要翻墙)</span></span><br><span class="line">sudo apt-get build-dep linux</span><br><span class="line">sudo apt-get install libncurses-dev flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf fakeroot <span class="comment">##装不上的先跳过</span></span><br></pre></td></tr></table></figure><p>读取写入通用内核配置项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes <span class="string">&#x27;&#x27;</span> | make oldconfig</span><br></pre></td></tr></table></figure><p>编译裁减内核项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>配置项完整内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable CONFIG_PREEMPT_RT</span></span><br><span class="line"> -&gt; General Setup</span><br><span class="line">  -&gt; Preemption Model (Fully Preemptible Kernel (Real-Time))</span><br><span class="line">   (X) Fully Preemptible Kernel (Real-Time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable CONFIG_HIGH_RES_TIMERS</span></span><br><span class="line"> -&gt; General setup</span><br><span class="line">  -&gt; Timers subsystem</span><br><span class="line">   [*] High Resolution Timer Support</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable CONFIG_NO_HZ_FULL</span></span><br><span class="line"> -&gt; General setup</span><br><span class="line">  -&gt; Timers subsystem</span><br><span class="line">   -&gt; Timer tick handling (Full dynticks system (tickless))</span><br><span class="line">    (X) Full dynticks system (tickless)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set CONFIG_HZ_1000 (note: this is no longer in the General Setup menu, go back twice)</span></span><br><span class="line"> -&gt; Processor <span class="built_in">type</span> and features</span><br><span class="line">  -&gt; Timer frequency (1000 HZ)</span><br><span class="line">   (X) 1000 HZ</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set CPU_FREQ_DEFAULT_GOV_PERFORMANCE [=y]</span></span><br><span class="line"> -&gt;  Power management and ACPI options</span><br><span class="line">  -&gt; CPU Frequency scaling</span><br><span class="line">   -&gt; CPU Frequency scaling (CPU_FREQ [=y])</span><br><span class="line">    -&gt; Default CPUFreq governor (&lt;choice&gt; [=y])</span><br><span class="line">     (X) performance</span><br></pre></td></tr></table></figure><p>部分内核版本编译项目存在差异,实时内核运行需要确保核心配置生效才能正常使用，内核项目的配置会对实时性造成影响，后续若是实时性不满足要求，则需要对裁减项进行深度优化，这部分是需要深层次学习的。</p><h5 id="确保："><a href="#确保：" class="headerlink" title="确保："></a>确保：</h5><ul><li>General setup —&gt; Preemption Model —&gt; Fully Preemptible Kernel (RT) selected</li><li>Kernel hacking —&gt; Memory Debugging —&gt; Check for stack overflows not selected<h4 id="4-编译内核-10-30min-on-a-modern-cpu"><a href="#4-编译内核-10-30min-on-a-modern-cpu" class="headerlink" title="4.编译内核(10-30min on a modern cpu)"></a>4.编译内核(10-30min on a modern cpu)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc` deb-pkg</span><br></pre></td></tr></table></figure><h4 id="5-安装内核"><a href="#5-安装内核" class="headerlink" title="5.安装内核"></a>5.安装内核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls ../*deb ##编译完成后会产生4个.deb结尾的安装包</span><br><span class="line">sudo dpkg -i ../*.deb  ##可以全部安装，也可以只安装header ，image两个包</span><br></pre></td></tr></table></figure><h4 id="6-更改内核启动项"><a href="#6-更改内核启动项" class="headerlink" title="6.更改内核启动项"></a>6.更改内核启动项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub   ##更新内核配置项</span><br></pre></td></tr></table></figure>执行上述命令，得到类似下面结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sourcing file `/etc/default/grub&#x27;</span><br><span class="line">Sourcing file `/etc/default/grub.d/init-select.cfg&#x27;</span><br><span class="line">正在生成 grub 配置文件 ...</span><br><span class="line">找到 Linux 镜像：/boot/vmlinuz-5.13.0-52-generic</span><br><span class="line">找到 initrd 镜像：/boot/initrd.img-5.13.0-52-generic</span><br><span class="line">找到 Linux 镜像：/boot/vmlinuz-5.13.0-51-generic</span><br><span class="line">找到 initrd 镜像：/boot/initrd.img-5.13.0-51-generic</span><br><span class="line">找到 Linux 镜像：/boot/vmlinuz-.419.72-rt26</span><br><span class="line">找到 initrd 镜像：/boot/initrd.img-4.19.72-rt26</span><br><span class="line">找到 Windows Boot Manager 位于 /dev/sda1@/efi/Microsoft/Boot/bootmgfw.efi</span><br><span class="line">找到 Ubuntu 18.04.2 LTS (18.04) 位于 /dev/sdb2</span><br><span class="line">Adding boot menu entry for UEFI Firmware Settings</span><br><span class="line">完成</span><br></pre></td></tr></table></figure>修改/etc/default/grub 文件内容,选择“boot/vmlinuz-.419.72-rt26”  第五个内核项编号项为4，修改内容如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT=&quot;1&gt; 4&quot;</span><br></pre></td></tr></table></figure>再次执行grub更新，使修失败改生效。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-重启并验证"><a href="#7-重启并验证" class="headerlink" title="7. 重启并验证"></a>7. 重启并验证</h4><p>重启后在终端命令行输入 uname -r</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">4.19.72-rt26</span><br></pre></td></tr></table></figure><hr><p><strong>注：第六步grub引导文件修改错误会导致进入系统失败，内核编译有问题也会导致进入系统失败。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 实时内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux-RT </tag>
            
            <tag> preempt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和风天气（实现自动更新定位）</title>
      <link href="/2022/01/07/hf-get-location/"/>
      <url>/2022/01/07/hf-get-location/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="和风天气（实现自动更新定位）"><a href="#和风天气（实现自动更新定位）" class="headerlink" title="和风天气（实现自动更新定位）"></a>和风天气（实现自动更新定位）</h3><blockquote><p>书接上文，在使用和风API获取实时气象数据以及天文服务时，需要传入地理位置参数(或预设位置信息)，感到困惑的是和风的”city_id”,貌似不是通用的ID号，对比高德和第三方的API接口，获取到城市ID好像记得是一致的，或许遵循某种标准 ，暂时不予深究。</p></blockquote><h4 id="emsp-拿到行政区划-公网IP"><a href="#emsp-拿到行政区划-公网IP" class="headerlink" title="&emsp;拿到行政区划/公网IP"></a>&emsp;拿到行政区划/公网IP</h4><p>&emsp;因为和风接口的原因，若是采用城市ID作为访问参数，必须通过和风城城市信息查询接口来得到ID号（和风自己对城市ID进行了编码，非通用编码）。为了得到这个ID，原计划通过网络查询到大致城市区划，拿到市级定位通过和风城市信息查询接口获得城市ID，方便后面气象资料查询。<a href="https://dev.qweather.com/docs/api/geo/city-lookup/">和风城城市信息查询接口文档</a><br><img src="./hf_city.png" alt="Alt text"><br>第一步肯定要解决市级定位问题，尝试用了百度、谷歌、腾讯、阿里、新浪、搜狐…等几个接口，单说这几个大公司的接口，基本上都要进行开发者认证，高德还好支付宝直接可以认证，但一开始也没计划使用高德，当然这里也有个例外，搜狐和ipify不需要认证，不需要鉴权信息。<br><a href="https://pv.sohu.com/cityjson?ie=utf-8">搜狐</a> &emsp;&emsp;<a href="https://api.ipify.org/?format=json">ipify</a><br>&emsp;<img src="./souhu.png" alt="Alt text"><br>&emsp;<img src="./ipify.png" alt="Alt text"><br>区别就是搜狐除了能得到IP外，还可以获取行政区划，也因此选用搜狐接口(一开始没打算用IP，因为和风接口入参是行政区划)。</p><h4 id="emsp-测试和风城市信息查询"><a href="#emsp-测试和风城市信息查询" class="headerlink" title="&emsp;测试和风城市信息查询"></a>&emsp;测试和风城市信息查询</h4><p>&emsp;拿到行政区划，开开心心的用浏览器发了几条请求，没问题开心的一批。<br><img src="./get_city_req.png" alt="Alt text"><br>&emsp;顺手把json解析部分一口气写完了，当放到设备上进行访问测试时出了问题，又是一脸懵逼….服务器返回400.一开始以为传参有问题，改了参数还是400，复制请求url 浏览器测试200正常，但是设备上就是不行。<br><img src="./get_city_id.png" alt="Alt text"><br>&emsp;改了改，还是不行，看了浏览器请求头，没思路。怀疑由于这个接口是商用接口，服务器那边可能会有请求设备信息检查或者设备类型识别检查。按理来是，设备层伪造请求信息模拟浏览器或许能骗过服务器，唉！懒得花时间分析，主要没啥用，还贼费劲，即得看设备接口库，又得反复监听分析服务器及浏览器消息传输。直接一个工单，看看和风如何回复吧。</p><h4 id="emsp-通过高德获取经纬度定位"><a href="#emsp-通过高德获取经纬度定位" class="headerlink" title="&emsp;通过高德获取经纬度定位"></a>&emsp;通过高德获取经纬度定位</h4><p>&emsp;由于和风城市接口的问题，在诸多尝试未果后，决定弃用城市查询接口，直接在实时气象和天文api接口中传入经纬度来获取，步骤没多没少，只不过是要借助第三方获取经纬度的API接口。<br><img src="./gd_gf.png" alt="Alt text"><br>&emsp;从认证层面考虑，方便的就高德了。上图是高德IP定位的接口，分了两个版本2.0的支持IPV6，普通版只是IPV4。选哪个都无所谓，反正只需要用了IPV4。不过普通接口提供的是左上右下一对经纬坐标，2.0的则只返回一组，其他没啥区别。</p><h4 id="emsp-测试高德定位"><a href="#emsp-测试高德定位" class="headerlink" title="&emsp;测试高德定位"></a>&emsp;测试高德定位</h4><p>&emsp;同样拿着IP地址，去浏览器测试高德接口，浏览器测试通过(图示2.0)。<br><img src="./gd_test.png" alt="Alt text"><br>&emsp;浏览器测试，没问题！！！改了下接口，继续在设备上进行测试。<br><img src="./gd_ip.png" alt="Alt text"><br><strong>行政区划正常！</strong><br><strong>IP获取正常！！</strong><br><strong>经纬度定位正常！！！</strong><br><strong>实时气象数据获取正常！！！！</strong><br><strong>天文数据获取正常！！！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和风天气 </tag>
            
            <tag> API </tag>
            
            <tag> IP获取 </tag>
            
            <tag> 定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录最近一次博客迁移之(Vercel)</title>
      <link href="/2022/01/03/vercel/"/>
      <url>/2022/01/03/vercel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="记录最近一次博客迁移之-Vercel"><a href="#记录最近一次博客迁移之-Vercel" class="headerlink" title="记录最近一次博客迁移之(Vercel)"></a>记录最近一次博客迁移之(Vercel)</h3><blockquote><p>最初博客部署在云端，用Django做了整套网页，大概是那会因为特殊原因(学校经费充裕，自己又在学前端，又菜又爱折腾)，连前后端一起搞了。毕业后参加工作，django维护成本太高，发个帖子部署一堆，费力不讨好。又因为懒得不行，博客更新闲置了。21年偶尔机会了解到hexo，静态的博客框架，正好适合我，于是就逐渐将博文迁移到Hexo上，之前自己做完全写在html里，也没用markdown导致迁移很是费力。21年也逐渐停掉了云，域名，hexo静态网页以仓库形式托管在github.io上，但由于github访问速度受到限制，决定再次映射到Vercel(也是不久刚了解到)。</p></blockquote><p>&emsp;Vercel 解决最根本的问题是可以关联github仓库，可自动化监测git状态，并触发自动部署。可以关联自己的域名，也可以使用Vercel提供的域名(速度还挺快)。<br><img src="./1.png" alt="Alt text"><br>&emsp;Vercel 登陆可以使用github直接授权登陆，无需注册也很方便。<br><img src="./2.png" alt="Alt text"><br>&emsp;在项目中添加github账号，即可扫描到github所有仓库，添加部署即可。<br><img src="./3.png" alt="Alt text"><br>&emsp;需要设置下项目名称，类型可选，点击并应用更改，Vercel将自动检测并完成部署。<br><img src="./4.png" alt="Alt text"><br>&emsp;在项目setting中可以设置域名，Vercel生成的就挺快的，省了域名的钱。美滋滋～～</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rl库开发笔记(Q&amp;A)</title>
      <link href="/2021/12/31/robotics-library/"/>
      <url>/2021/12/31/robotics-library/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="./2.gif" alt="show" /><h4 id="1-如何更新场景和视图，以便我可以模拟机器人移动？"><a href="#1-如何更新场景和视图，以便我可以模拟机器人移动？" class="headerlink" title="1.如何更新场景和视图，以便我可以模拟机器人移动？"></a>1.如何更新场景和视图，以便我可以模拟机器人移动？</h4><blockquote><p>为了在解决方案路径的每个配置中可视化机器人，您必须计算每个点的前向运动学并同步机器人的运动学和几何模型。通过获取和设置每个机器人身体的框架来完成。这两个方法在rl::plan::Model ，rl::plan中进行了组合和更新，在rlPlanDemo应用中也用到了。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;mdl-&gt;forwardPosition(); </span><br><span class="line"> </span><br><span class="line">if (doUpdateModel) </span><br><span class="line">&#123; </span><br><span class="line">for (::std::size_t i = 0; i &lt; this-&gt;model-&gt;getNumBodies(); ++i) </span><br><span class="line">&#123; </span><br><span class="line">this-&gt;model-&gt;getBody(i)-&gt;setFrame(this-&gt;mdl-&gt;getBodyFrame(i)); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 关于如何设置动画的示例代码也可以在 rlPlanDemo<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> rl::plan::VectorList::iterator i = path.<span class="built_in">begin</span>(); </span><br><span class="line"> rl::plan::VectorList::iterator j = ++path.<span class="built_in">begin</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (i != path.<span class="built_in">end</span>() &amp;&amp; j != path.<span class="built_in">end</span>()) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">drawConfiguration</span>(*i); </span><br><span class="line">QThread::<span class="built_in">usleep</span>(<span class="keyword">static_cast</span>&lt;std::<span class="keyword">size_t</span>&gt;(<span class="number">0.01</span> * <span class="number">1000.0</span> * <span class="number">1000.0</span>)); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">rl::math::Real delta = MainWindow::<span class="built_in">instance</span>()-&gt;viewer-&gt;delta; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (; i != path.<span class="built_in">end</span>() &amp;&amp; j != path.<span class="built_in">end</span>(); ++i, ++j) </span><br><span class="line">&#123; </span><br><span class="line">rl::math::Real steps = std::<span class="built_in">ceil</span>(MainWindow::<span class="built_in">instance</span>()-&gt;model-&gt;<span class="built_in">distance</span>(*i, *j) / delta); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (std::<span class="keyword">size_t</span> k = <span class="number">1</span>; k &lt; steps + <span class="number">1</span>; ++k) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;running) <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">MainWindow::<span class="built_in">instance</span>()-&gt;model-&gt;<span class="built_in">interpolate</span>(*i, *j, k / steps, inter); </span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">drawConfiguration</span>(inter); </span><br><span class="line">QThread::<span class="built_in">usleep</span>(<span class="keyword">static_cast</span>&lt;std::<span class="keyword">size_t</span>&gt;(<span class="number">0.01</span> * <span class="number">1000.0</span> * <span class="number">1000.0</span>)); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>为了在 Qt 中制作动画，同时仍然能够与您的 GUI 交互，您通常必须使用单独的线程。由于带有 3D 模型的小部件是Qt 主线程的一部分，因此您必须使用Qt 信号和插槽在它们之间进行通信。这也用于rlPlanDemo.</p><h4 id="2-对机器人模型进行自定义更改-向我们从-URDF-导入的机器人模型添加更多链接和框架-目前不支持std-make-shared"><a href="#2-对机器人模型进行自定义更改-向我们从-URDF-导入的机器人模型添加更多链接和框架-目前不支持std-make-shared" class="headerlink" title="2.对机器人模型进行自定义更改,向我们从 URDF 导入的机器人模型添加更多链接和框架.(目前不支持std::make_shared)"></a>2.对机器人模型进行自定义更改,向我们从 URDF 导入的机器人模型添加更多链接和框架.(目前不支持std::make_shared)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rl::mdl::Frame* new_frame = <span class="keyword">new</span> rl::mdl::<span class="built_in">Frame</span>();</span><br><span class="line">new_frame-&gt;<span class="built_in">setName</span>(<span class="string">&quot;new_frame&quot;</span>);</span><br><span class="line">model_-&gt;<span class="built_in">add</span>(new_frame);</span><br><span class="line"></span><br><span class="line">rl::mdl::Fixed* new_frame_fixed_link_ = <span class="keyword">new</span> rl::mdl::<span class="built_in">Fixed</span>();</span><br><span class="line">model_-&gt;<span class="built_in">add</span>(new_frame_fixed_link_, eef_frame, new_frame);</span><br><span class="line">new_frame_fixed_link_-&gt;<span class="built_in">setName</span>(<span class="string">&quot;eef_to_new_link&quot;</span>);</span><br><span class="line">model_-&gt;<span class="built_in">update</span>();</span><br></pre></td></tr></table></figure><h4 id="3-移动机器人碰撞检测"><a href="#3-移动机器人碰撞检测" class="headerlink" title="3.移动机器人碰撞检测"></a>3.移动机器人碰撞检测</h4><blockquote><p>移动机械手的一个很好的例子是 UMan（参见运动学和几何模型），它结合了 Nomad XR4000 底座和 Barrett WAM 机械手。为了使用运动学模型和给定的配置q更新几何模型，您首先必须使用基于空间向量代数的 rl::mdl API 或（不推荐使用的） rl::kin API 计算前向位置运动学基于经典的 Denavit-Hartenberg 符号：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rl::mdl::XmlFactory factory;</span><br><span class="line"><span class="function">std::shared_ptr&lt;rl::mdl::Model&gt; <span class="title">model</span><span class="params">(factory.create(<span class="string">&quot;model.xml&quot;</span>))</span></span>;</span><br><span class="line">rl::mdl::Kinematic* kinematic = <span class="keyword">dynamic_cast</span>&lt;rl::mdl::Kinematic*&gt;(model.<span class="built_in">get</span>());</span><br><span class="line">kinematic-&gt;<span class="built_in">setPosition</span>(q);</span><br><span class="line">kinematic-&gt;forwardPosition();</span><br></pre></td></tr></table></figure><p>然后，您可以根据计算出的框架更新几何模型各个主体的世界框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rl::sg::Model* model = scene.<span class="built_in">getModel</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">getNumBodies</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">model-&gt;<span class="built_in">getBody</span>(i)-&gt;<span class="built_in">setFrame</span>(kinematic-&gt;<span class="built_in">getBodyFrame</span>(i)); <span class="comment">// for current master branch</span></span><br><span class="line"><span class="comment">// model-&gt;getBody(i)-&gt;setFrame(kinematic-&gt;getFrame(i)); // for 0.7 branch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-如何通过坐标求逆解"><a href="#4-如何通过坐标求逆解" class="headerlink" title="4.如何通过坐标求逆解"></a>4.如何通过坐标求逆解</h4><blockquote><p>该演示rlInversePositionDemo首先使用正向运动学来确保为以下 IK 计算提供有效的末端执行器框架。为了使用您自己的目标框架，请将第 100 行正向运动学计算的框架替换为您自己rl::math::Transform的运动学模型可达的框架。以下是 Mitsubishi RV-6SL 运动学模型的示例mitsubishi-rv6sl.xml，其中旋转指定为 Euler-ZYX ( z = 0°, y = 90°, x = 0°) 并且平移设置为 ( x = 0.595 m, y = 0.0 米，z = 0.83 米）：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rl::math::Transform goal;</span><br><span class="line">goal.<span class="built_in">linear</span>() = rl::math::<span class="built_in">AngleAxis</span>(<span class="number">0.0</span> * rl::math::DEG2RAD, rl::math::Vector3::<span class="built_in">UnitZ</span>()) *</span><br><span class="line">rl::math::<span class="built_in">AngleAxis</span>(<span class="number">90.0</span> * rl::math::DEG2RAD, rl::math::Vector3::<span class="built_in">UnitY</span>()) *</span><br><span class="line">rl::math::<span class="built_in">AngleAxis</span>(<span class="number">0.0</span> * rl::math::DEG2RAD, rl::math::Vector3::<span class="built_in">UnitX</span>()).<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">goal.<span class="built_in">translation</span>() = rl::math::<span class="built_in">Vector3</span>(<span class="number">0.595</span>, <span class="number">0.0</span>, <span class="number">0.83</span>);</span><br><span class="line">ik.<span class="built_in">addGoal</span>(goal, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了你自己的IK计算，你可以跳过的正运动学计算line:77-89，并在随机初始化line:102-110。</p><h4 id="5-使用场景加载和-SimpleScene-检查碰撞"><a href="#5-使用场景加载和-SimpleScene-检查碰撞" class="headerlink" title="5.使用场景加载和 SimpleScene 检查碰撞"></a>5.使用场景加载和 SimpleScene 检查碰撞</h4><blockquote><p>为了使用 rl::sg::SimpleScene 执行碰撞检查，请确保使用从此类派生的引擎。rl::sg::so::Scene（Open Inventor/Coin3D 抽象）仅支持 3D 可视化，不实现rl::sg::SimpleScene。.为此，请使用 Bullet、FCL、ODE、PQP 或 SOLID 引擎：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rl::sg::solid::Scene scene;</span><br><span class="line">rl::sg::XmlFactory factory;</span><br><span class="line">factory.<span class="built_in">load</span>(<span class="string">&quot;scene.xml&quot;</span>, &amp;scene);</span><br><span class="line"><span class="keyword">bool</span> isColliding = scene.<span class="built_in">isColliding</span>();</span><br><span class="line"><span class="comment">//-- bool areColliding = dynamic_cast&lt;rl::sg::SimpleScene*&gt;(&amp;scene)-&gt;areColliding(</span></span><br><span class="line"><span class="comment">//--  scene.getModel(0), scene.getModel(1)</span></span><br><span class="line"><span class="comment">//-- );</span></span><br><span class="line"><span class="keyword">bool</span> areColliding = scene.<span class="built_in">areColliding</span>(scene.<span class="built_in">getModel</span>( <span class="number">0</span> ),scene.<span class="built_in">getModel</span>( <span class="number">1</span> ));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> robotics library </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和风天气API接口调用(日出日落信息)</title>
      <link href="/2021/12/26/hf-weather/"/>
      <url>/2021/12/26/hf-weather/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="和风天气API接口调用-日出日落信息"><a href="#和风天气API接口调用-日出日落信息" class="headerlink" title="和风天气API接口调用(日出日落信息)"></a>和风天气API接口调用(日出日落信息)</h3><hr><blockquote><p> &emsp;&emsp;前段时间忙着对外项目，偶然机会想在设备端使用API获取日落时间，用于满足自动化切换。起初项目是使用心知天气API，因涉及到“商用“…….（胡说.八道，哈哈哈哈…反正甲方也不知道，用免费的接口就行，无奈心知天气日出日落需要付费，程序写了七七八八改也麻烦，何况资金也算充足，所幸良心发现就没有薅羊毛，不过确实付费的要稳定很多）。<br> &emsp;&emsp;后来想自己做一款Homekit自动化终端，实现联动控制。其实HomeKit的自动化构建功能还是蛮强大的，我其实最看好的“离家模式“”，hass平台上可以通过noderead编写工作流，设备层通过蓝牙扫描手机蓝牙来判断（毕竟大多数时候手机不离身），但这个有个缺点就是蓝牙必须一直开着。利用Homkit原生自动化场景可以很轻松实现这个功能，不需要去部署hass，也能正常使用。当然其所灵活性方面来说，还是更倾向Hass，可集成的功能真的是太多了。考虑到设计的目的是为了送人，还越简单越好。</p></blockquote><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li>arduino IDE （完全是为了偷懒，因为arduino库很全，我也没过多时间放在这上面，虽然idf框架开发也会，但是整体要比arduino复杂很多，当然IDF性能会好点） </li><li> ESP32芯片（乐鑫）</li><li> API（心知天气付费的嘛，找了找“和风天气”对于地理位置类API是免费的，继续薅）<h4 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h4></li><li>说实话，一开始没想过要找和风天气的API接口库，API调用本来不复杂，就是http/https请求嘛，只要发的出去，解析的回来不就成了，浏览和风官网发现有个ESP8266的库。</li><li><img src="./hf_api.png" alt="Alt text">&emsp;哈哈哈，要啥有啥，ESP8266虽然说不能直接应用于ESP32设备，但是API核心发送，解析是网络层应用和设备没关系哇，那就改改设备驱动的那快呗，本来两款芯片都内置wifi库的，所以就替换下接口的事。随后更新到我的github上吧，毕竟开源协议要靠大家共同遵守维护的。<h4 id="爬坑之旅"><a href="#爬坑之旅" class="headerlink" title="爬坑之旅"></a>爬坑之旅</h4><blockquote><p>以为接口移植好了，天气信息/日出日落返回正常，本打算收工歇息了。烧录进去测试发现天气获取正常，日出日落返回一直无法解析的乱码。<br><img src="./hf_error.png" alt="Alt text"></p><h6 id="emsp-当场蒙圈了-啥问题，API不对？那为啥服务器返回200-，对比API和发送请求"><a href="#emsp-当场蒙圈了-啥问题，API不对？那为啥服务器返回200-，对比API和发送请求" class="headerlink" title="&emsp;当场蒙圈了,啥问题，API不对？那为啥服务器返回200 ，对比API和发送请求"></a>&emsp;当场蒙圈了,啥问题，API不对？那为啥服务器返回200 ，对比API和发送请求</h6><p><img src="./hf_G0.png" alt="Alt text"><br><img src="./hf_G1.png" alt="Alt text"></p><h6 id="emsp-我去没啥毛病啊，再对比下实时天气的请求和返回参数。"><a href="#emsp-我去没啥毛病啊，再对比下实时天气的请求和返回参数。" class="headerlink" title="&emsp; 我去没啥毛病啊，再对比下实时天气的请求和返回参数。"></a>&emsp; 我去没啥毛病啊，再对比下实时天气的请求和返回参数。</h6><p><img src="./hf_G2.png" alt="Alt text"><br><img src="./hf_G3.png" alt="Alt text"><br><strong>难道编码不对？arduino貌似也是utf-8输出吧，要是改编码那我得知道改成啥格式的才行。emo……了半天，决定看下服务器返回所有信息</strong>。<br><img src="./HF_dbug1.png" alt="Alt text"><br><img src="./HF_dbug0.png" alt="Alt text"><br>&emsp;<strong>折腾了半天，还打算换编码来着，对比一看都是utf-8没毛病，可是为啥日出日落带着压缩参数，返回上面看API页面，实时天气有，但是日出日落没写gzip参数啊！！！入坑一小步，爬坑爬半天，官方手册不可不信也不能全信。在日出日落请求加上无压缩参数，顺利搞定。</strong><br><img src="./solve.png" alt="Alt text"></p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tools_web</title>
      <link href="/2021/12/24/tools-web/"/>
      <url>/2021/12/24/tools-web/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.51cto.com/solin/1865855">将当前的Ubuntu系统封装成为可以安装（发布）的iso镜像</a><br><a href="https://help.ubuntu.com/community/LiveCDCustomization">ubuntu 官网镜像定制</a><br><a href="https://docs.orocos.org/">kdl</a><br><a href="https://hexo.io/zh-cn/docs/configuration">hexo</a><br><a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%81%B4%E9%82%8A%E6%8E%92%E7%89%88">butterfly</a><br><a href="http://marxi.co/">marxi</a><br><a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11iAZjf2">ubuntu20.04 换源</a><br><a href="https://www.howtogeek.com/howto/22145/how-to-create-your-own-customized-ubuntu-live-cd/">How to Create Your Own Customized Ubuntu Live CD</a><br><a href="https://ostechnix.com/how-to-create-a-custom-ubuntu-live-iso-image-with-cubic/">How To Create A Custom Ubuntu Live ISO Image With Cubic</a><br><a href="https://www.video2edit.com/zh/convert/mp4-to-gif">mp4 to gif</a><br><a href="https://www.pexels.com/zh-cn/search/videos/%E6%9C%BA%E5%99%A8%E4%BA%BA/">视频素材</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethercat开源主站(soem)禾川伺服csp模式测试</title>
      <link href="/2021/10/15/ethercat-soem-hafc/"/>
      <url>/2021/10/15/ethercat-soem-hafc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Ethercat开源主站-soem-禾川伺服csp模式测试"><a href="#Ethercat开源主站-soem-禾川伺服csp模式测试" class="headerlink" title="Ethercat开源主站(soem)禾川伺服csp模式测试"></a>Ethercat开源主站(soem)禾川伺服csp模式测试</h3><h4 id="1-Ethercat基础介绍"><a href="#1-Ethercat基础介绍" class="headerlink" title="1.Ethercat基础介绍"></a>1.Ethercat基础介绍</h4><p>&emsp;EtherCAT（Ethernet for Control Automation Technology）是一种基于以太网的实时工业现场总线通讯协议，由德国倍福公司提出并研发投入使用，2003 年引入市场，2007 年成为国际标准，2014 年成为中国国家标准，并在中国成立EtherCAT 一致性检测中心，为 EtherCAT 技术在中国的发展和应用奠定了一定的基础。<br>EtherCAT 作为实时工业以太网技术和标准，发展迅速，由于其具有传输距离远、传输速度快、连接的从站设备可达65535个、灵活的网络拓扑结构等优势近年来被广泛关注。EtherCAT 采用全双工通信，最大限度地利用网络带宽，报文带宽利用率大于 90%，数据传输速率接近 100Mb/s；通过一个以太网帧，可以传输 1486 字节的有效过程控制数据，相当于约 12000 个数字量 IO，而这些数据量的传输仅需要几百微秒甚至几十微秒。例如，EtherCAT 对于 256 个数字 IO 刷新时间为 11us；100 节点上 1000 个开关量刷新时间 30us；100 个伺服轴刷新时间也只有 100us。EtherCAT 技术支持的分布式时钟也为各个从站设备提供了同步性，例如将用于机器人的各个伺服轴作为从站，轴之间的同步时间偏差小于 1us，为各个轴的插补运动控制提供了基础。EtherCAT 不需要提供专门的硬件设备与配置，使其成本低廉，使用方便，加之其高实时性，在工业自动化、物联网应用等领域中 EtherCAT 技术的使用正在成为一种趋势。<br>EtherCAT的核心技术在于从站设备层，主站通信可是任何Ethernet标准设备，与网络帧区别于特殊帧头，数据帧结构大体类似。下图为倍福EtherCAT从站控制芯片(ESC)，虽说后续有新产品新功能问世，但也保留最初ET1100大部分特性(保留一代芯基础寄存器配置),市面上常用的美国微芯(lan9252),台湾亚信(AX58100) EtherCAT控制芯片都采用标准寄存器配置。了解ET1100可以很快熟悉从站配置流程，以及获取准确的设备运行状态。<br><img src="./1.png" alt="Alt text"><br>&emsp;EtherCAT从站通信控制器(ESC,EtherCAT Slave Controller),负责处理Ethercat数据帧，并使用双端口存储区实现主从站本地应用数据交换。ET1100支持两种物理接口：MII和EBUS。 MII是标准以太网物理层接口，定义与传输介质无关的标准电气接口。MII模式配合物理层芯片(PHY，用于数据编码、译码、收发),即可完成数据交互。EBUS是倍福公司根据LVDS(Low Voltage Differential Signaling)标准定义的数据传输协议，不需要额外物理层芯片，可以直连ESC芯片，避免了物理层附加延时。ET1100 过程数据接口(PDI,Process Date Interfaces)支持3种通信控制方式，IO模式，即无需外部MCU可直接使用32路引脚用作IO控制。SPI模式，ESC作为SPI从站与MCU连接，单片机通过SPI总线对ESC进行读写配置。同步或异步总线模式，通过8/16路数据地址总线对ESC进行操作(类似内存读写操作)，实现数据交互以及配置。</p><h4 id="2-EtherCAT-主站控制流程"><a href="#2-EtherCAT-主站控制流程" class="headerlink" title="2.EtherCAT 主站控制流程"></a>2.EtherCAT 主站控制流程</h4><p>&emsp;EtherCAT状态机(ESM, EtherCAT State Machine),负责协调主站和从站应用程序在初始化和运行时的状态关系及转换；从初始化状态至运行状态，必须按照“初始化-&gt;预运行-&gt;安全运行-&gt;运行”的顺序转化,从运行状态逆向返回时可以越级转化。<br>主站系统采用标准以太网协议，不依赖于专用芯片，只要满足Ethernet通信的单片机，PC，工控机等设备，就可以实现ESC设备的通信控制。目前最流行的两大EtherCAT开源主站框架：SOEM，IGH。即在嵌入式设备，PC终端借助Ethernet以太网实现EtherCAT主站功能。<br>&emsp;首先，明白从站状态机有那些模式，以及不同模式下开启的功能和可执行的操作方式。<br><img src="./2.png" alt="Alt text"><br>&emsp;ESC从站设备上电后处于INIT模式，INIT模式下主站首先会执行清理配置寄存器的操作，主要涉及FMMU寄存器(内存管理单元，将从站物理地址与应用层逻辑地址进行映射，0x0600-0x06ff为从站寄存器地址)和同步管理器SM(用于主从站应用程序数据交互)，其次，配置从站地址(0x0010)，发送接收邮箱对应寄存器(0x0800-0x080f),对于DC模式下的设备(伺服电机周期模式)，需要设置DC分布式时钟控制器寄存器，INIT模式下这部分主要是读取系统时钟，计算时钟偏差配置从站本地时钟。从站的SM同步管理器被配置、邮箱切换运行状态，状态机请求切换到P-OP状态(PRE-OPERATIONAL).<br><img src="./3.png" alt="Alt text"><br>&emsp;初始化完成后，从站会运行在P-OP状态，此状态下主站需要配置从站PDO映射(涉及SM同步管理器、FMMU内存管理单元相关寄存器配置)，以及DC模式下同步模式、同步周期等操作。P-OP模式下邮箱被激活，输入数据有效，SDO在此模式下通常用于配置PDO映射。从站响应配置后，主站将发生P-OP到S-OP状态切换请求。<br><img src="./4.png" alt="Alt text"><br>&emsp;S-OP状态下主站对从站的配置工作基本完成，此时过程数据有效，但输出处于安全态。此时运动指令不会被电机、伺服响应。从站保持与主站基本通信连接(心跳数据、特殊标志寄存器状态轮询)，等待主站发生S-OP 到OP状态请求。一但从站切换到OP状态，PDO数据将会被电机响应，电机正常运动。</p><h4 id="3-PDO映射关系"><a href="#3-PDO映射关系" class="headerlink" title="3.PDO映射关系"></a>3.PDO映射关系</h4><p>&emsp;PDO映射主要在过程数据通信时，将用户层逻辑地址与设备层地址联系起来，用户层在操作设备时，无需关系设备物理地址，只需往映射的逻辑地址内存写入数据并发生，从站会自动提取网络数据帧中对应的字段数据执行，简化用户层的操作，提高通信速率。<br><img src="./5.png" alt="Alt text"><br> 每个PDO在对象字典中用2个对象描述，分别是PDO通信参数和映射参数。</p><ul><li>1） PDO通信参数：定义该设备所使用的COB-ID、传输类型、定时周期。</li><li>2） PDO映射参数：包含一个对象字典中的对象列表，这些对象映射到相应的PDO，其中包括数据的长度。对于生产者和消费者，只有知道这个映射参数，才能够正确地解释PDO的内容。PDO内容是预定义的，如果PDO支持可变PDO映射，那么可以通过SDO进行配置。<br>PDO    映射地址存在范围，RxPDO 地址是0x1600-0x17ff ,TxPDO 地址范围0x1a00-0X1BFF 理论上只要映射条目不超过地址范围，都是有效映射。但实际中不同厂家设备多少有些差异(与从站设备有关)。上图展示基本PDO映射流程。主要涉及三部分，Mapping区，Assignment区，对象字典。Mapping区分为发送区和接收区，通过地址区分，存放的是映射条目组,0x1600为起始地址也是第一组组地址，组内数据为对象字典条目地址(如0x604000010，0x607A0020，上图0x7000,0x6000属于开放区域地址，换句话来说，此地址可以在从站设备单片机程序中内修改替换，但用户必须和从站设备匹配)，Assignment区主要对应的是SM2,SM3同步管理器PDO数据收发区域，SM0,SM1为邮箱的收发区。SM2,SM3内存放的是Mapping区条目地址。这很好理解，上述说到逻辑地址与物理地址映射需要FMMU单元来实现，FMMU主要是将SM区条目映射到用户逻辑地址，SM区条目又与设备物理地址存在映射关系，即整个物理地址与用户逻辑地址具备完整映射关系。<br>以禾川电机举例：RXPDO通信参数保存在0x1c12，映射参数地址0x1600-0x17ff，可以将0x1600.01设置为0x604000010，表示长度为0x10(16) 位的0x6040.00(控制字)映射到0x1600.01；将0x1600.02设置为0x607A0020，表示长度为0x20(32) 位的0x607A.00(控制字)映射到0x1600.02。<h4 id="4-抓包分析"><a href="#4-抓包分析" class="headerlink" title="4.抓包分析"></a>4.抓包分析</h4>&emsp;EtherCAT可以使用wireshark抓包工具进行以太网抓包，对于EtherCAT专用设备转接卡的主站设备，抓包可能存在问题。转接模块使用非本机网口的设备(PCI转接卡,USB卡等)，可串入交换机进行抓包测试。下述将举例说明，抓包调试基本方法。<br><img src="./6.png" alt="Alt text"><br>&emsp;使用wireshark抓取工控机网口1数据，工控机使用SOEM库作为EtherCAT主站,初始化控制禾川EtherCAT伺服电机，抓取网口数据包，上图为其中一帧数据。EtherCAT datagram中,可以看到主站发起广播写命令(BWR)，寄存器FMMU逻辑单元(0x600),SM同步管理器(0x800)将被设置(图4-2，寄存器被清空，设备在INIT阶段主站执行操作，详见图2-1)。<br><img src="./7.png" alt="Alt text"><br><img src="./8.png" alt="Alt text"><br>&emsp;接着取一帧PDO映射部分数据帧，PDO映射首先要清除RPDP、TPDO、SM2 、SM3数据，然后再依次写入新的数据。具体操作如下，将0x1c12,0x1c13子索引0置位，0x1600,0x1a00子索引0置位，写入0x1600,0x1a00 子索引1，2，3…数据，将配置条目数写入子索引0，将0x1600,0x1a00对应写入0x1c12 ,0x1c13子索引1，配置子索引0条目数。<br><img src="./9.png" alt="Alt text"><br><img src="./10.png" alt="Alt text"><br>&emsp;使用SOEM，IGH库可以实现嵌入式设备、PC端主站控制系统开发，搭配实时内核、嵌入式微内核，主站同步周期可缩短至微秒级(与挂载设备数量也存在一定关系，网口数据转发也需要耗时)。在嵌入式linux终端(树莓派4)上测试SOEM控制禾川6轴伺服，1ms周期插补无压力。<br><img src="./11.png" alt="Alt text"> <img src="./12.png" alt="Alt text"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ethercat </category>
          
          <category> Soem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethercat </tag>
            
            <tag> Soem </tag>
            
            <tag> Servo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_note</title>
      <link href="/2019/11/04/C-note/"/>
      <url>/2019/11/04/C-note/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p><p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>堆区：</strong></p><p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​        在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p><p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​    语法：<code> new 数据类型</code></p><p>​    利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="keyword">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年龄 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="assets/1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="assets/1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li></ul><ul><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> age ,<span class="keyword">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">m_age = p.m_age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> 类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li> 所有对象共享同一个函数</li><li> 静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="keyword">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mB; </span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li> 当形参和成员变量同名时，可用this指针来区分</li><li> 在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p2, <span class="keyword">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p2.m_A + val;</span><br><span class="line">temp.m_B = p2.m_B + val;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="keyword">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="assets/1544861202252.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="assets/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="assets/1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="assets/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line"><span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="assets/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Num1;</span><br><span class="line"><span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//普通实现测试</span></span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Num1;</span><br><span class="line"><span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建加法计算器</span></span><br><span class="line">AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建减法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建乘法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="assets/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourInCup</span>();</span><br><span class="line"><span class="built_in">PutSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line"><span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoCard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelCPU</span> :</span><span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelVideoCard</span> :</span><span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelMemory</span> :</span><span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoCPU</span> :</span><span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoVideoCard</span> :</span><span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoMemory</span> :</span><span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p><p>​</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件 </li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建输出流对象</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、打开文件</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、写文件</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新型智能家居组网方式研究</title>
      <link href="/2019/05/30/thesis-10/"/>
      <url>/2019/05/30/thesis-10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="第八章-新型智能家居组网方式研究"><a href="#第八章-新型智能家居组网方式研究" class="headerlink" title="第八章 新型智能家居组网方式研究"></a>第八章 新型智能家居组网方式研究</h4><h5 id="8-1-传统组网方式存在的问题"><a href="#8-1-传统组网方式存在的问题" class="headerlink" title="8.1 传统组网方式存在的问题"></a>8.1 传统组网方式存在的问题</h5><p>&emsp;现阶段智能家居设备大都使用wifi、zigbee的方式进组网，在进行一定市场调查后，我发现一个有趣的现象，对于物联网智能家居的单一产品来说，无不例外都使用的wifi的方式来实现设备联网;对于成套的智能家居系统来说，总控制器与子设备间大都使用的zigbee 方式进行组网。那么这么做的主要原因是什么呢？相对于单个智能家居产品来说，使用wifi方式联网成本更低，联网方式简单，但是有个致命的缺点就是，家用路由器AP连接容量很小，路由器可连接的终端是有限的，这就意味着智能家居设备不能太多。尽管近几年路由器厂商不断的改良，连接量从最初的9个，到现在40个左右，但过多的连接量会导致网络质量下降，影响手机、电脑、平板等移动设备正常上网。对于成套的智能家居系统，终端节点数量是比较多的，使用wifi的方式组网显然是不可取的。使用zigbee的原因在于协调器与节点之间采用2.4G射频传输，节点之间自组网。协调器通过网口、wifi的方式连接到路由器就可以实现广域网的传输通信，路由器只需要挂载一个协调器就能实现整个室内智能家居设备的联网。因此，由于节点间不采用wifi进行传输，与路由器连接需要协调器转化，成本相对较大，且协调器作为核心设备一旦故障，整个与广域网的连接将会中断。</p><h5 id="8-2-基于WIFI的MESH-组网技术"><a href="#8-2-基于WIFI的MESH-组网技术" class="headerlink" title="8.2  基于WIFI的MESH 组网技术"></a>8.2  基于WIFI的MESH 组网技术</h5><p>&emsp;对于智能家居来说，我可能更倾向与使用wifi方式来实现组网，因为家用WIFI如今已是很普遍，智能家居设备选用wifi的方式连接路由器上网，相对于zigbee组网来说成本较低，但对于wifi设备来说，我们希望它能实现像zigbee一样终端节点间自组网。自组网的好处在于，终端设备会因所处的位置不同，动态的调整网络结构。设备即可以作为叶子节点，也可作为中间节点、根节点。作为中间节点时，充当路由的角色。作为根节点时，充当局域网网关的角色。因此，引入基于wifi传输的mesh组网技术，来实现wifi设备间自组网。当wifi设备使用mesh进行组网时，根据信号强弱，离路由器最近的wifi设备将被选为根节点，根节点再根据自身AP的覆盖范围，选取距离自己较近的几个设备作为中间节点，同理，中间节点会继续向下延伸，连接跟多的中间节点、子节点。当根节点发生故障时，节点间会发生一轮选举，距路由器距离次之的设备，因此时信号强度最强，会被推选为新的根节点。利用wifi实现mesh组网，根节点作为mesh网络的网关，直接与路由器连接，不需要其他设备转化传输协议，因此，目前来说MESH 组网技术成本相对较低，且最为合理的。</p><h5 id="8-3-MESH-组网测试"><a href="#8-3-MESH-组网测试" class="headerlink" title="8.3  MESH 组网测试"></a>8.3  MESH 组网测试</h5><p>&emsp;测试选用乐鑫公司生产的ESP32低功耗、wifi蓝牙二合一模组，作为控制器，外接BH1750光强传感器、oled屏、sht30温湿度传感器，实现对环境温湿度、光照强度采集，显示在OLED屏上。使用乐鑫ESP-MDF开发框架，实现设备间mesh组网，调用TCP/IP功能模块，与后端服务器对接，将温湿度及光照强度传输至云端，并在web页面上进行实时显示。<br><img src="./1.png" alt="Alt text"><br>&emsp;ESP-MDF是乐鑫基于MESH协议栈开发的组网框架，使用ESP-MDF框架可以快速开发ESP32模组，实现配网、升级、调试控制等功能，内置mesh协议，方便设备间快速组网。<br>ESP-MDF框架是在linux环境下进行开发的，因此，掌握必要的linux指令是开发的前提，当然，为了方便通常会在windows系统上，通过安装虚拟机系统来搭建linux环境。但虚拟机系统的安装配置也算较为复杂的过程。官网也推荐在windows系统上使用msys2 小型的GNU环境进行开发。使用msys2搭建开发环境，步骤如下：</p><ul><li>1.在乐鑫官网下载msys2安装包，然后在C盘进行解压。解压完成后打开msys32目录，双击运行“mingw32.exe”文件。</li><li>2.弹出黑色命令框，即msys2启动成功。接着使用“mkdir”命令在用户目录下创建一个名为“esp”的目录，用来区分管理编译工程。<br>mkdir –p  ~/esp</li><li>3.进入创建的esp目录<br>cd ~/esp</li><li>4.使用“git”命令下载“esp-mdf”开发框架。<br>git clone –recursive <a href="https://github.com/espressif/esp-mdf.git">https://github.com/espressif/esp-mdf.git</a></li><li>5.进入下载的“esp-mdf”，执行更新命令，确保开发框架克隆完整。<br>git submodule update –init</li><li>6.设置环境变量。<br>在C:/msys32/etc/profile.d/ 目录下创建一个新的脚本文件，将其命名为“export_<br>idf_path.sh”，在脚本中写入如下命令：<br>export IDF_PATH=”C:/msys32/home/Administrator/esp/esp-mdf”</li><li>7.验证环境变量是否配置成功,若返回路径一致，则配置成功，开发环境搭建完成。<br>printenv MDF_PATH<br>接下来只需根据官方手册，按照函数接口说明，按需求编写设计驱动程序，即可实现快速的开发。</li></ul><p><strong>测试底板原理图：</strong><br>&emsp;为了方便搭建测试电路，设计制作了搭载有光强传感器、温湿度传感器、OLED的测试底板，原理图、PCB如下所示：<br>&emsp;<img src="./3.png" alt="Alt text"><br>&emsp;&emsp;&emsp;&emsp;<img src="./4.png" alt="Alt text"></p><h5 id="8-4-测试结果"><a href="#8-4-测试结果" class="headerlink" title="8.4  测试结果"></a>8.4  测试结果</h5><p>&emsp;设计制作了10块基于ESP32的温湿度、光照强度检测节点，利用mesh组网技术，进行环境数据采集后，上传至后端云服务器。测试设备可以实现自适应组网，在设备运行过程中间歇性的撤掉根节点电源来模拟根节点故障，其他设备依然可以在短时间内重新建立根节点，保证网络链路的通畅。<br>&emsp;后端TCP服务器可以正常收到来自mesh网络上传的数据，在对数据进行简单滤波后存入mysql数据库，且数据稳定可靠。<br>web服务器可以正常从数据库中读取各个测试节点的数据，并将数据分类后以可视化的图表表现出来。<br><img src="./5.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2后端服务器测试</title>
      <link href="/2019/04/22/thesis-9-2/"/>
      <url>/2019/04/22/thesis-9-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="7-2后端服务器测试"><a href="#7-2后端服务器测试" class="headerlink" title="7.2后端服务器测试"></a>7.2后端服务器测试</h4><p>&emsp;后端服务器测试了TCP服务器、MQTT服务器、WEB服务器的连接状况，TCP、MQTT服务器作为设备终端枢纽，主要负责数据的接收存储、指令下达。web服务器则负责将数据库中的数据读取并通过前端页面进行展示。<br><img src="./1.png" alt="Alt text"><br><img src="./2.png" alt="Alt text"><br><img src="./3.png" alt="Alt text"><br>测试结果：<br>&emsp;设备服务器可以接收到来自设备传输的数据，并存入数据库，nginx、uwsgi可以快速处理浏览器请求，各服务器功能正常，且满足预期设计需求。但由于所购买的云服务器是学生版，系统配置较低、带宽不够，受条件因素限制，所以在压力测试时表现不好。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 系统测试</title>
      <link href="/2019/04/13/thesis-9-1/"/>
      <url>/2019/04/13/thesis-9-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="第七章-系统测试"><a href="#第七章-系统测试" class="headerlink" title="第七章 系统测试"></a>第七章 系统测试</h4><h5 id="7-1-硬件系统测试"><a href="#7-1-硬件系统测试" class="headerlink" title="7.1 硬件系统测试"></a>7.1 硬件系统测试</h5><p>在完成硬件系统设计后，接着我对硬件系统做了多次测试，测试主要为检验系统稳定性、控制可靠性。</p><ul><li>方案一：<br>STM32+ESP8266+继电器：使用STM32搭载ESP8266 wifi模块构建最小物联网控制单元，引出控制引脚与继电器模组相连实现对“STM32+ESP8266”控制方案进行实际测试，测试系统不间断运行时间，频繁发送控制指令时系统反应能力测试.<br><img src="./1.png" alt="Alt text"></li><li>方案二：<br>ESP8266+DHT11+HLW8032：使用ESP8266作为控制单元，搭载DHT11数字式温湿度传感器，HLW8032电量检测芯片完成测试，主要对电路板进行控制测试，以及MQTT协议上传数据测试。<br><img src="./2.png" alt="Alt text"><br>&emsp;ESP8266电源控制柜：二次回路以ESP8266为控制单元，使用光耦搭建继电器驱动电路，通过继电器控制一次回路的交流接触器、各房间供电支路，实现对总电源、房间电源自动化管理。主要完成对设备进行远程控制、语音控制、百度智能家居商用接口控制测试。<br><img src="./3.png" alt="Alt text"></li></ul><p><strong>硬件电路测试结果：</strong><br>&emsp;在对方案一进行测试时，我采用了TCP、MQTT两种方式与设备云服务器进行连接，在不排除网络不稳定因素的情况下，从测试反应的速度来看，设备连接量较少时两种方式都很灵敏，若是接入的设备量增加，MQTT在指令接收方面会受到影响，存在动作迟滞的现象，分析主要原因，初步判定为硬件设备订阅了相同的主题，设备也会接收其他设备的控制指令，这些无关指令虽然不会触发设备执行控制动作，但是设备处理判别消息是需要花费时间的，数据流过大时，迟滞现象最明显，甚至会漏掉执行指令。为解决控制迟滞问题，将来可通过设计多个消息主题来对不同场合设备进行分类，减轻设备端处理无关数据带来的负担。<br>&emsp;在对方案二进行测试时，总体表现比较满意，唯一要注意的是在软件设计过程中，合理使用内存资源，因为“ESP8266”模组本身内部就运行着Free RTOS系统占用内存资源，在程序运算量较大或临时变量存储过多时，会导致设备重启。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4 Dueros智能家居商用接口对接</title>
      <link href="/2019/03/27/thesis-8-4/"/>
      <url>/2019/03/27/thesis-8-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="6-4Dueros智能家居商用接口对接"><a href="#6-4Dueros智能家居商用接口对接" class="headerlink" title="6.4Dueros智能家居商用接口对接"></a>6.4Dueros智能家居商用接口对接</h4><p>&emsp;设计最初的目标是在以个人现有的知识水平为基础，尽可能的使所设计产品趋近于商用级别。Dueros官方考虑到智能家居设备控制在实际生活中会存在一些安全隐患，所以针对智能家居设备规定了一套标准的控制协议来确保设备控制的安全性，且对申请上线的设备有着严格的审核，需要把样机邮寄到总部进行测试，只有测试通过的产品才能被正式授权。当然本次设计制作的硬件，仅完成了商用接口协议的对接，并没有送审授权，所以也只能被个人使用。<br><img src="./1.png" alt="Alt text"><br>&emsp;dueros的智能家居其实从服务器角度看，也属于技能范畴，它与自定义技能的区别就是，智能家居技能不需要处理逻辑对话的服务器，因此智能家居技能不可以自定义问答内容。<br>智能家居技能是通过百度出品智能音箱进行语言交互控制的，个人搭建的交互终端不开放智能家居权限，当然如果你是厂商，需要赋予自己产品语言交互的能力，则需要通过商业合作的方式获取权限。需要注意的是智能家居技能需要一个oauth2.0授权服务器进行授权，这个基于oauth2.0协议的授权服务器需要我们自己来搭建的。<br>对于oauth2.0授权非专业的人事可能不太了解，但在生活中绝对使用过。最常见的就是访问一个网站，网站可以使用第三方账号进行登陆。以CSDN网站为例，简单介绍下oauth授权过程，以便对接下来的智能家居授权有个深入理解。<br><img src="./2.png" alt="Alt text"><br>&emsp;我们在CSDN首页点击登陆时，假如选用第三方QQ登陆，浏览器会给CSDN网站发送一个授权的请求，这时CSDN网站会返回一个重定向的地址，这里重定向的地址就是QQ授权服务器的地址，接着浏览器将自动访问这个地址，请求QQ授权服务器授权。QQ授权服务器收到浏览器的授权请求后，会返回一个code码，也就是授权码。浏览器接着携带着授权码再向CSDN发起请求，CSDN第二次收到请求后，会解析提取请求中携带的授权码，并通过授权码向QQ授权服务器发起请求，换取token令牌，QQ授权服务器验证授权码有效后，会返回token令牌给CSDN，CSDN拿到token令牌后，会再次请求QQ授权服务器，用token令牌换取用户信息，只有QQ授权服务器验证token正确后，会返回用户信息给CSDN，CSDN拿到用户信息后，经过查找、筛选、读取等处理，将用户对应的数据渲染到页面上，并将渲染后的页面返回给浏览器。此时就达到了第三方账号授权登陆目的。<br>对于智能家居技能来说，在创建技能时需要配置oauth2.0授权服务器,并将服务器地址填入技能配置项内，配置完成后dueros服务器会自动去请求ouath2.0授权服务器，通过一系列的请求应答，获取到token令牌。在每次通过智能音箱下达语音控制指令时，dueros服务器会携带token令牌去请求设备云，设备云需要根据智能家居协议进行适配，才可以实现控制。协议包括了各种常用的家电，针对不同的控制电器也有不同的控制标准，如灯类除控制开关外，还有调色、调光的接口，空调有调温、模式切换、定时开关等接口。设备云在设计时，必须按协议正确且及时的回复应控制结果，dueros服务器才会根据控制结果，使智能音箱做出不同的回应。除此之外，设备云还需要对dueros请求携带的token令牌做校验，设定token令牌的过期时间，只有严格遵循这些规则，才能使智能家居设备和音箱正常交互，保障控制系统稳定运行。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3 逻辑处理服务设计</title>
      <link href="/2019/03/10/thesis-8-3/"/>
      <url>/2019/03/10/thesis-8-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="6-3-逻辑处理服务设计"><a href="#6-3-逻辑处理服务设计" class="headerlink" title="6.3 逻辑处理服务设计"></a>6.3 逻辑处理服务设计</h4><p>&emsp;在硬件终端搭建完成后，需要设计一组逻辑对话，适用于语音控制场景。例如：“打开卧室的台灯”，“关闭厨房电源”，“设置空调温度为24摄氏度”等。以及部署控制指令转发的服务器地址。在dueros官网，这些逻辑处理的对话场景统称为技能，所以只需要设计好逻辑对话技能，然后在服务器上部署，就可以实现语音控制。<br>&emsp;首先需要在dueros官网，技能平台创建自定义技能，并编辑简单的对话模型，用于确定识别关键字位置。接着将常见控制关键字录入数据字典，dueros在分析对话内容时，通过关键字来确定是否是有效指令。在完成对话模型，字典设计后，可以通过网页端进行简单的语句理解测试，如果语句识别准确无误，即可以进行具体的逻辑设计了。<br>&emsp;逻辑设计的内容将来会部署在服务器上，dueros给开发者提供了两种部署方式，一种是百度云cfc函数计算，另一种是“web server”部署，也就是开发者在第三方平台上的云服务器。针对这两种方式提供了两中对应的开发模板。支持的开发语言为java、php、nodejs，逻辑设计我将采用nodejs来完成，因为cfc函数计算默认开发语言为nodejs，虽然支持Python、java但是兼容不是很友好。<br> &emsp;选用cfc函数计算，需要登陆百度云，创建cfc函数计算实例，选用模板创建会生成dueros匹配的代码模板，只需要改写入口参数，就可以在此基础上进行逻辑的扩展，且cfc函数计算代码可以直接在线编辑修改，非常方便。但是cfc函数计算运行环境是百度云提供的，只有一些必备的、常见的插件，我们没有办法去修改、添加或自定义自己的插件，所以cfc函数计算可以说是比较局限的，不太适合复杂，庞大的逻辑处理。因此,我将采用第二种方式，在自己云服务器上搭建一个web server，然后编写逻辑代码实现部署。<br><strong>搭建“web server”首先需要搭建nodejs运行环境，具体步骤如下：</strong></p><ul><li>1.首先使用ssh方式登陆到云服务器上，在home目录下创建个node文件夹。<br>cd /home<br>mkdir node</li><li>2.下载git工具, centos默认工具是“yum”，ubuntu替换为“apt-get”即可<br>sudo yum install git</li><li>3.下载安装NVM版本管理工具<br>curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh">https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh</a> | bash</li><li>4.重新加载“.bashrc”文件<br>source ~/.bashrc</li><li><ol start="5"><li>查询全部可以安装的nodejs版本号<br>nvm ls-remote</li></ol></li><li>6.安装指定版本（dueros要求nodejs版本必须大于v6.10）<br>nvm install v8.1.2</li><li>7.查看当前使用版本，验证安装是否成功<br>nvm current</li><li>8.现在需要在npm上下载“bot-sdk”包,以及依赖的软件包<br>cd node<br>npm install bot-sdk –save<br>npm install express –save</li><li>9.“web server”的方式，其实是搭建一个小型的http服务器，将逻辑对话按要求编写成文件，dueros服务器通过http请求访问逻辑服务器，逻辑服务器返回对应的对话，所以按照官网要求，需要用nodejs语言搭建个http服务器。<br>新建一个名为index.js的文件：</li></ul><blockquote><p>vi index.js</p></blockquote><p><strong>编写http服务器，代码如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Bot = <span class="built_in">require</span>(<span class="string">&#x27;./Bot&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="comment">// 探活请求</span></span><br><span class="line">app.head(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.sendStatus(<span class="number">204</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    req.rawBody = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    req.setEncoding(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        req.rawBody += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="keyword">new</span> Bot(<span class="built_in">JSON</span>.parse(req.rawBody));</span><br><span class="line">        b.run().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            res.send(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8016</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;listen 8016&#x27;</span>);</span><br></pre></td></tr></table></figure><p>&emsp;此段代码，启用http服务，监听8016端口，在官网技能服务配置时也应以“ip+端口”号方式来配置逻辑对话服务器地址，如：“<a href="http://154.36.24.8:8016”接下来就是设计编写逻辑对话的代码了，官方规定使用Bot.js来命名逻辑代码。下面注释了逻辑代码基础结构,自定义的逻辑对话内容的开发在此基础上迭代就可以，与设备云的连接控制，在逻辑处理的过程中以http请求的方式发送给设备云，即可对物联网只能家居硬件进行控制。">http://154.36.24.8:8016”接下来就是设计编写逻辑对话的代码了，官方规定使用Bot.js来命名逻辑代码。下面注释了逻辑代码基础结构,自定义的逻辑对话内容的开发在此基础上迭代就可以，与设备云的连接控制，在逻辑处理的过程中以http请求的方式发送给设备云，即可对物联网只能家居硬件进行控制。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BaseBot = <span class="built_in">require</span>(<span class="string">&#x27;bot-sdk&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bot</span> <span class="keyword">extends</span> <span class="title">BaseBot</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * postData可以不传，由于DuerOS对bot是post请求，sdk默认自动获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">postData</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(postData);</span><br><span class="line">            <span class="built_in">this</span>.addLaunchHandler(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">outputSpeech</span>: <span class="string">&#x27;欢迎使用!&#x27;</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.addIntentHandler(<span class="string">&#x27;personal_income_tax.inquiry&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ctrl = <span class="built_in">this</span>.getSlot(<span class="string">&#x27;dz&#x27;</span>);</span><br><span class="line">            <span class="keyword">let</span> local = <span class="built_in">this</span>.getSlot(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">            <span class="keyword">let</span> device = <span class="built_in">this</span>.getSlot(<span class="string">&#x27;device&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!ctrl) &#123;</span><br><span class="line"><span class="keyword">let</span> card = <span class="keyword">new</span> Bot.Card.TextCard(<span class="string">&#x27;请问您是要打开还是关闭&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.nlu.ask(ctrl);</span><br><span class="line">                 <span class="comment">//  如果有异步操作，可以返回一个promise</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">                        resolve(&#123;</span><br><span class="line">                            <span class="attr">directives</span>: [<span class="built_in">this</span>.getTemplate1(<span class="string">&#x27;请问您是要打开还是关闭&#x27;</span>)],</span><br><span class="line">                            <span class="attr">outputSpeech</span>: <span class="string">&#x27;请问您是要打开还是关闭&#x27;</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">                <span class="keyword">let</span> card = <span class="keyword">new</span> Bot.Card.TextCard(<span class="string">&#x27;请问您要控制的设备在哪里&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.nlu.ask(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">                  <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">card</span>: card,</span><br><span class="line">                    <span class="attr">outputSpeech</span>: <span class="string">&#x27;请问您要控制的设备在哪里&#x27;</span></span><br><span class="line">                  &#125;;</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">if</span> (!device) &#123;</span><br><span class="line">                   <span class="keyword">let</span> card = <span class="keyword">new</span> Bot.Card.TextCard(<span class="string">&#x27;请问您要控制的设备是什么&#x27;</span>);</span><br><span class="line">                   <span class="built_in">this</span>.nlu.ask(device);</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">directives</span>: [<span class="built_in">this</span>.getTemplate1(<span class="string">&#x27;请问您要控制的设备是什么&#x27;</span>)],</span><br><span class="line">                        <span class="attr">outputSpeech</span>: <span class="string">&#x27;请问您要控制的设备是什么&#x27;</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;到此，语音交互设计就基本完成了，在完成上述工作后，可以在dueros技能平台测试调试你所编写的对话技能，在树莓派端使用或者调试的技能需要通过语音指令的方式，切换到调试技能模式，然后打开“xxx”技能，即可完成调试测试，但对于控制类的技能，官方是不允许通过自定义的技能方式申请上线的，也就是说通过自定义技能创建的具有智能家居功能的自定义技能，只可以在测试模式下使用，且只能被你个人所用。虽然控制功能现在基本已经实现，但这并不满足我要的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2 语音识别终端搭建</title>
      <link href="/2019/02/16/thesis-8-2/"/>
      <url>/2019/02/16/thesis-8-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="6-2-语音识别终端搭建"><a href="#6-2-语音识别终端搭建" class="headerlink" title="6.2 语音识别终端搭建"></a>6.2 语音识别终端搭建</h4><p>&emsp;选用PS3 eye摄像头进行拾音，PS3 eye摄像头内置4个拾音麦克风，但并非专用的远场设别麦克风整列板，所以降噪处理的效果不太理想。当然，也有一些表现优秀的且适合树莓派的麦克风整列板，比如ReSpeaker 系列2mic、4mic、6mic，硬件上集成专用的音频处理芯片，配合语音算法，实现波束成形、噪声抑制、混响消除、回声消除等功能。但是考虑到专用麦克风整列板价格昂贵，文档资料较少，二次开发难度大，遂选用PS3 eye代替，PS3 eye使用USB直接与树莓派连接，不仅可以输出音频信号，还可以输出图像信号，且价格便宜。树莓派选用3b作为开发平台，使用16G的内存卡烧录最新的树莓派系统，作为树莓派启动盘。硬件一切准备工作就绪后，我们将开始下载安装dueros 基于Python语音开发的软件包，具体步骤如下：</p><ul><li>1.因涉及修改系统文件，所以直接切换到root用户下操作<br>  su – root</li><li>2.在用户根目录下下载安装软件包，切换到用户根目录<br>  cd  ~/</li><li>3.使用git命令，到github上下载软件包<br>  git clone <a href="https://github.com/MyDuerOS/DuerOS-Python-Client.git">https://github.com/MyDuerOS/DuerOS-Python-Client.git</a></li><li>4.登陆dueros官网设备控制台，创建设备，配置授权地址。</li><li>5.在树莓派端进入DuerOS-Python-Clinent/app目录<br> cd DuerOS-Python-Clinent/app</li><li>6.编辑当前目录的auth.py文件<br>  vi auth.py</li><li>7.将开发者信息替换为，注册设备的信息。<br> CLIENT_ID=“xxxx”<br> CLIENT_SECRET=“xxxx”</li><li>8.返回上一层目录，启动授权文件<br>cd /home/pi/DuerOS-Python-Client/<br>./suth.sh</li><li>9.打开浏览器，输入授权服务地址<br> <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a></li><li>10.在授权页面登陆百度账号完成授权</li><li>11.运行语音服务器<br> ./wakeup_trigger_start.sh<br>&emsp;到此，树莓派3b语音交互的终端就搭建完成了，启动语音服务后，即可与树莓派正常交谈对话，也可以点歌，控制音乐播放暂停。但现在交互终端只相当于一款人工智能音箱，要想通过树莓派控制物联网设备，还需要部署用于逻辑处理对话的云服务器。<br><img src="./1.png" alt="Alt text"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 语音交互及兼容框架设计</title>
      <link href="/2019/01/20/thesis-8-1/"/>
      <url>/2019/01/20/thesis-8-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第六章-语音交互及兼容框架设计"><a href="#第六章-语音交互及兼容框架设计" class="headerlink" title="第六章 语音交互及兼容框架设计"></a>第六章 语音交互及兼容框架设计</h3><h4 id="6-1-语音交互框架设计"><a href="#6-1-语音交互框架设计" class="headerlink" title="6.1 语音交互框架设计"></a>6.1 语音交互框架设计</h4><p>&emsp;语音交互控制一直是这两年智能家居行业的热点话题，传统的物联网控制方式以满足不了人们的生活需求，融入人工智能的语音交互技术恰恰是新型控制方式的主导，语音交互控制的优点在于用户可以摆脱手机、遥控、电脑等移动终端，直接通过对话的方式控制物联网智能家居设备。目前语音交互的核心技术掌握大公司手里，语音交互的推广，恰好可以缓解当前智能家居行业设备厂商APP五花八门，用户体验差的局面。本设计也是依附于大公司语音识别引擎，进而与上述搭建完成后端服务器对接，使硬件设备兼容语音控制的功能。<br><img src="./1.png" alt="Alt text"><br>&emsp;设计所用的语音识别硬件终端为：树莓派3b，远场设别麦克风整列。树莓派3b主要是提供一个稳定、便携的linux平台，用来运行百度dueros语音交互系统。远场识别麦克风整列主要功能是对场景进行录音，并将录音进行降噪处理后，传给树莓派3b，承担着拾音、处理等任务。<br>&emsp;语音交互控制的框架运行流程：远场麦克风整列对环境进行录音，将录音内容经过算法降噪处理后传输给树莓派，树莓派对降噪后的录音内容进行分段处理后，转化成“百度大脑”所需要的格式，打包上传给“百度大脑”，“百度大脑”进行分析识别录音结果，将识别结果转发给用户用于处理语音交互逻辑的服务器，接着逻辑服务器向设备云发送控制指令，设备云接收到控制指令后，按硬件设备通信协议格式进行转化，然后下发给硬件设备。控制指令执行成功后，设备云返回逻辑服务器控制结果，逻辑服务器按照返回的控制结果，返回给百度大脑对应的逻辑对话内容，百度大脑将需要合成的语音内容返回给树莓派系统，树莓派接收后进行进一步处理，最后控制扬声器播放。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4 Nginx服务器部署</title>
      <link href="/2018/12/16/thesis-7-4/"/>
      <url>/2018/12/16/thesis-7-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="5-4-Nginx服务器部署"><a href="#5-4-Nginx服务器部署" class="headerlink" title="5.4 Nginx服务器部署"></a>5.4 Nginx服务器部署</h4><p>Nginx是高性能的http服务器/web反向代理服务器，其结构小巧、占用内存少、并发能力强，被广泛的应用在网站开发领域。Nginx代码是用C语言写的，因此运行速度在同类产品中具有很强的优势。<br>Nginx同样也不属于系统预装软件，需要用户去官网下载。具体步骤如下：</p><ul><li>1）登陆官网下载安装包，地址如下<br><a href="http://nginx.org/">http://nginx.org/</a></li><li>2）下载“nginx-1.6.3.tar.gz”到当前路径</li><li>3）执行解压命令<br>tar zxvf nginx-1.6.3.tar.gz</li><li>4）进入nginx-1.6.3文件夹，依次执行以下命令进行安装<br>./configure<br>Make<br>Sudo make install </li><li>5）默认安装到/usr/local/nginx/目录，进入此目录<br>cd /usr/local/nginx/</li><li>6）启动<br>sudo sbin/nginx<br>到此nginx安装就已完成，但是要想与uwsgi服务器联通，还需要进一步配置，具体过程如下：<ul><li>1）打开conf/nginx.conf文件<br>sudo gedit conf/nginx.conf</li><li>2）在server节点下添加新的location项，指向uwsgi的ip与端口<br>location / {<br>include uwsgi_params;           #将所有的参数转到uwsgi下<br>uwsgi_pass 127.0.0.1:8080;      #uwsgi的ip与端口<br>}</li><li>3）打开conf/nginx.conf文件<br>sudo gedit conf/nginx.conf</li><li>4）在server节点下添加新的location项，用于处理静态文件<br>location /static {<br>alias /var/www/test6/static/;<br>}</li><li>5）在服务器上创建如下目录<br>sudo mkdir -vp /var/www/test6/static/</li><li>6）修改目录权限<br>sudo chmod 777 /var/www/test6/static/</li><li>7）修改django项目中settings.py文件。<br>STATIC_ROOT=’/var/www/test6/static/‘<br>STATIC_URL=’/static/‘</li><li>8）收集所有静态文件到static_root指定目录<br>python manage.py collectstatic</li><li>9）停止后再启动nginx服务</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3 uwsgi服务器部署</title>
      <link href="/2018/11/24/thesis-7-3/"/>
      <url>/2018/11/24/thesis-7-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="5-3-uwsgi服务器部署"><a href="#5-3-uwsgi服务器部署" class="headerlink" title="5.3 uwsgi服务器部署"></a>5.3 uwsgi服务器部署</h4><p>在生产环境中使用WSGI作为python web的服务器。WSGI：全拼为Python Web Server Gateway Interface，Python Web服务器网关接口，是Python应用程序或框架和Web服务器之间的一种接口，被广泛接受。WSGI没有官方的实现, 因为WSGI更像一个协议，只要遵照这些协议，WSGI应用(Application)都可以在任何服务器(Server)上运行。<br>uWSGI实了WSGI的所有接口，是一个快速、自我修复、开发人员和系统管理员友好的服务器。uWSGI代码完全用C编写，效率高、性能稳定。安装部署uwsgi服务器步骤如下：</p><ul><li>1）安装uwsgi<blockquote><p>pip install uwsgi</p></blockquote></li><li>2）配置uWSGI，在项目目录下创建uwsgi.ini文件，配置如下：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="comment">#使用nginx连接时使用</span></span><br><span class="line"><span class="comment">#socket=127.0.0.1:8080</span></span><br><span class="line"><span class="comment">#直接做web服务器使用</span></span><br><span class="line"><span class="attr">http</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="comment">#项目目录</span></span><br><span class="line"><span class="attr">chdir</span>=/home/python/Desktop/pytest/test6</span><br><span class="line"><span class="comment">#项目中wsgi.py文件的目录，相对于项目目录</span></span><br><span class="line"><span class="attr">wsgi-file</span>=test6/wsgi.py</span><br><span class="line"><span class="attr">processes</span>=<span class="number">4</span></span><br><span class="line"><span class="attr">threads</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">master</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">pidfile</span>=uwsgi.pid</span><br><span class="line"><span class="attr">daemonize</span>=uwsgi.log</span><br></pre></td></tr></table></figure></li><li>3）启动<blockquote><p>uwsgi –ini uwsgi.ini</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2  WEB后端实现</title>
      <link href="/2018/11/09/thesis-7-2/"/>
      <url>/2018/11/09/thesis-7-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="5-2-WEB后端实现"><a href="#5-2-WEB后端实现" class="headerlink" title="5.2  WEB后端实现"></a>5.2  WEB后端实现</h4><p>WEB后端理论上通过编写个http服务端，用户访问http服务器时，通过解析url来返回用户访问的画面，就可以搭建个轻量级的网站。此方法我在实际测试中也得到了验证，但是存在一个致命的问题就是用这种方式搭建起来的网站，在压力测试中，表现很差，仅仅能满足测试环境的需求。对于生产环境，远远要比这复杂。本设计使用“nginx+uwsgi+django”的模式，以实际生产环境为标准，进一步完善后端服务器，实现数据可视化。</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="./1.png" alt="Alt text"></h4><p>Web后端框架如上图所示，浏览器访问web服务器请求首先会通过nginx负载均衡服务器，nginx会根据请求内容，将请求内容分为动态文件和静态文件两种，静态文件由nginx直接处理后返回给浏览器，动态文件会转发给uwsgi服务器来进行处理，uwsgi通过操作django框架完成动态数据的处理，将渲染后的数据再交给nginx，然后由nginx返回给浏览器。所以web后端实现分为三部分，分别为：django项目搭建，uwsgi服务器部署，nginx服务器部署。设计将围绕这三部分开展。</p><h5 id="5-2-1-Django项目搭建"><a href="#5-2-1-Django项目搭建" class="headerlink" title="5.2.1 Django项目搭建"></a>5.2.1 Django项目搭建</h5><p>Django框架是一款用python语言写的web开源框架，它遵循MVT结构，且有着大量第三方插件的支持，并具有很强的可扩展性。可以极大的降低开发工作量，使开发者简单快速的开发数据库驱动的网站。</p><blockquote><p>开发django项目，首先也要去下载搭建开发环境，具体步骤如下：<br>1.使用pip命令下载安装django安装包：<br>pip install django==1.8.2<br>2. 创建项目<br>mkdir pytest  #创建用于存放django项目的文件夹<br>cd pytest     #进入目标文件夹<br>django-admin startproject mesh_web  #创建名为“mesh_web”的项目<br>3. 创建应用<br>python manage.py startapp mesh_data  #创建名为“mesh_data”的应用<br><img src="./2.png" alt="Alt text"><br>M:Model,模型， 和MVC中M功能相同，和数据库进行交互。<br>V:View,视图， 和MVC中C功能相同，接收请求，进行处理，与M和T进行交互，返回应答。<br>T:Template,模板， 和MVC中V功能相同，产生html页面。</p></blockquote><h5 id="5-2-2-模型设计"><a href="#5-2-2-模型设计" class="headerlink" title="5.2.2 模型设计"></a>5.2.2 模型设计</h5><p>模型的作用主要是对数据库进行设计，在django中，访问mysql数据库不需要去手动的调用sql语句，django会根据模型文件，自动的完成数据库建表操作。用户只需要按规则编写模型文件即可。具体步骤 如下：</p><ul><li><p>1.定义模型类<br>模型类定义在models.py文件中，继承自models.Model类。下面代码功能为建立一个名字为“Book”数据表，表中有存放的内容为书的标题和发布时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    pub_date = models.DateField()</span><br></pre></td></tr></table></figure></li><li><p>2.生成迁移文件<br>完成模型类定义后，需要通过manage.py将定义好的模型类文件生成可以执行迁移文件，命令如下：</p><blockquote><p> python manage.py makemigrations</p></blockquote></li><li><p>3.执行迁移命令<br>只有在执行迁移命令后，上述设计的数据表才能在数据库中完成创建。</p><blockquote><p>python manage.py migrate</p></blockquote></li></ul><p>&emsp;服务器在收到这个请求之后，就一定对应着一个处理动作，这个处理动作就是帮我们产生页面内容并返回回来，这个过程是由视图来做的。对于django的设计框架MVT，用户在URL中请求的是视图，视图接收请求后进行处理，并将处理的结果返回给请求者。</p><h5 id="5-2-3-视图设计"><a href="#5-2-3-视图设计" class="headerlink" title="5.2.3 视图设计"></a>5.2.3 视图设计</h5><p>用户在浏览器中输入“<a href="http://www.xxxx.com”服务器在收到这个请求之后,就一定对应着一个处理动作,这个处理动作就是帮我们产生页面内容并返回回来,这个过程是由视图来做的./">www.xxxx.com”服务器在收到这个请求之后，就一定对应着一个处理动作，这个处理动作就是帮我们产生页面内容并返回回来，这个过程是由视图来做的。</a><br>对于django的设计框架MVT，用户在URL中请求的是视图，视图接收请求后进行处理，并将处理的结果返回给请求者。<br>视图函数的使用：</p><ul><li><ol><li>定义视图函数<br>视图函数定义在views.py中。<br>例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">      <span class="comment">#进行处理</span></span><br><span class="line">      <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;hello python&#x27;</span>)</span><br></pre></td></tr></table></figure>视图函数必须传入request参数，视图函数处理完成后，需要返回一个HttpResponse的类对象。<br>进行url配置。url配置的目的是让建立url和视图函数的对应关系。url配置项定义在urlpatterns的列表中，每一个配置项都调用url函数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line">urlpatterns=[</span><br><span class="line">    url(<span class="string">r&#x27;^$&#x27;</span>,views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>配置url时，有两种语法格式：</strong></p><ul><li>a) url(正则表达式，视图函数名)</li><li>b) url(正则表达式，include(应用中的urls文件))<br>工作中在配置url时，首先在项目的urls.py文件中添加配置项时，并不写具体的url和视图函数之间的对应关系，而是包含具体应用的urls.py文件，在应用的urls.py文件中写url和视图函数的对应关系。</li></ul><h5 id="5-2-4-模板设计"><a href="#5-2-4-模板设计" class="headerlink" title="5.2.4 模板设计"></a>5.2.4 模板设计</h5><p>&emsp;在django框架中，html网页页面代码统称为模板。模板的主要任务是实现外观表达，对于业务逻辑、数据处理，则应当由视图来完成。这种页面设计与业务逻辑分离的设计，有利于降低业务逻辑与页面显示之间的耦合，一个视图可以选择匹配到任意模板，一个模板也能被多个视图匹配。<br>&emsp;模板设计其实在本章第一节“前端页面设计”就已经完成了，顾不在赘述。只需要将html文件导入django项目的template文件夹下，然后在django的设置文件中配置template文件夹的路径即可。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 WEB数据可视化</title>
      <link href="/2018/10/30/thesis-7-1/"/>
      <url>/2018/10/30/thesis-7-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第五章-WEB数据可视化"><a href="#第五章-WEB数据可视化" class="headerlink" title="第五章 WEB数据可视化"></a>第五章 WEB数据可视化</h3><h4 id="5-1-前端页面设计"><a href="#5-1-前端页面设计" class="headerlink" title="5.1 前端页面设计"></a>5.1 前端页面设计</h4><p>&emsp;检测网络中各个数据采集节点将环境数据上传到云端服务器，云端服务器将环境数据存入数据库后，为了更直观的了解环境状况，需要将数据以可视化的方式表现出来。本次设计选用WEB的方式将数据通过浏览器渲染出来，无论是电脑端还是手机端都可以通过浏览器访问服务器地址实时监测实际环境的数据。<br>&emsp;Web数据可视化实际上是分为两个部分来实现的，分别是前端页面设计，以及后端数据处理。前端页面采用<strong>html+Css3+h5</strong>的结构来设计，后端数据处理是http服务器把利用从mysql数据库读取的内容渲染网页模板，将渲染后的网页数据发送给用户移动终端展示。前端页面采用第三方插件，绘制数字仪表、统计图、饼图，使环境数据能够直观的展示给用户。<br><img src="./1.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.5 接入第三方云服务器</title>
      <link href="/2018/05/30/thesis-6-5/"/>
      <url>/2018/05/30/thesis-6-5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="4-5-接入第三方云服务器"><a href="#4-5-接入第三方云服务器" class="headerlink" title="4.5 接入第三方云服务器"></a>4.5 接入第三方云服务器</h4><p>&emsp;在智能家居迅速发展的今天，大公司为了抢占市场拉拢客户，通常会建设自己的物联网开放平台，为中小型企业提供“设备云服务”，其实这与前面提到的“第三方云服务器”类似，运营模式也几乎一样，第三方平台给你提供开发环境和必要的网络服务，开发者只需负责业务开发，并提供一定的费用，即可完成业务的快速上线。中小型企业选用第三方物联网平台做为自己的设备服务器其实是有它自身理由的。首先，能够运营开放平台的基本都属于大公司，并且在物联网行业起步要早，技术相对成熟，中小企业为了在市场竞争中立于不败之地，选用大公司的开放平台来开发自己的业务更有保障。其次，搭建一套商用化物联网平台是昂贵的，涉及到技术相对复杂，开发需要的人力资源较大，且开发周期较长，更新维护、升级优化等都需要一大笔支出。中小企业往往需要的是快速推出自己的物联网产品，在系统建设、平台构建方面带来的利益短时间内并不明显，使用第三方平台开发是一个不错的选择。最后，因物联网行业仍处于初期阶段，大公司在互联网时代通用的战略，通常是先“圈地”，拉拢足够的用户，在行业比较稳定时，通过增收服务费来运营。就拿近两年“滴滴出行”、“摩拜单车”来说，这种租赁的服务刚推出的时候，几乎是免费的，甚至通过贴钱方式来拉拢、抢夺用户，这种情况下中小企业肯定会相继破产，只有财力雄厚的或许能坚持到最后，成为行业龙头，这时也拥有了足够的用户，各项资费相继提出。中小企业要想度过危机，通常选择依附大企业。<br>本节通过使用中移onenet物联网开放平台，使设备快速接入云服务，实现数据采集存储、指令控制、数据展示。具体步骤如下：<br>1)登陆ONENET官网，在开发中心创建产品，选用MQTT协议。<br>2)进入产品页面，创建设备，设置鉴权信息。<br>3)在硬件端进行编程，将MQTT服务器IP和端口指向onenet的MQTT服务器.并在设备连接时传入产品ID，产品密钥，设备ID，设备鉴权进行登陆验证。<br>4)根据ONENET MQTT协议，按要求订阅系统主题，上传传感器采集数据<br>5)在ONENET官网产品页面，开发轻应用页面。轻应用页面支持拖动布局，且完成后手机电脑端都能使用。<br><img src="./2.png" alt="Alt text"><br><img src="./3.png" alt="Alt text"><br><img src="./4.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4 MQTT服务端搭建</title>
      <link href="/2018/05/17/thesis-6-4/"/>
      <url>/2018/05/17/thesis-6-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="4-4-MQTT服务端搭建"><a href="#4-4-MQTT服务端搭建" class="headerlink" title="4.4 MQTT服务端搭建"></a>4.4 MQTT服务端搭建</h4><p>&emsp;Mqtt服务端作为控制网络的核心，起到连接各个控制设备，实现指令转发，数据处理等作用。Mqtt服务端的搭建与TCP、UDP、HTTP等常见的Client-Server模型有些不一样，它还需要一个broker 代理，且mqtt编程需要依赖名为“paho-mqtt”的模块，为此，我们要再次配置开发环境，步骤如下：<br>下载安装“paho—MQTT”模块：</p><blockquote><p>sudo pip install paho-mqtt<br>添加环境变量：<br>source paho-mqtt/bin/activate<br>下载 broker 代理：<br>sudo apt-get install mosquitto  mosquitto-clients<br>启动代理：<br>sudo server mosquitto  start<br>broker 代理启动起来后就可以来编写服务端了。具体代码如下所示：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入模块</span></span><br><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt </span><br><span class="line"><span class="comment">#定义一个连接回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span> </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Connected with result code &quot;</span>+<span class="built_in">str</span>(rc))</span><br><span class="line">client.subscribe(<span class="string">&quot;chat&quot;</span>) </span><br><span class="line"><span class="comment">#定义一个消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">client, userdata, msg</span>):</span> </span><br><span class="line"> <span class="built_in">print</span>(msg.topic+<span class="string">&quot; &quot;</span> + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(msg.payload))</span><br><span class="line"><span class="comment">#主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"> client = mqtt.Client() </span><br><span class="line">   <span class="comment"># 将回调函数指派给客户端实例</span></span><br><span class="line"> client.on_connect = on_connect </span><br><span class="line"> client.on_message = on_message </span><br><span class="line">   <span class="comment"># 连接到代理</span></span><br><span class="line"> client.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1883</span>, <span class="number">60</span>) </span><br><span class="line">   <span class="comment">#维持与MQTT代理之间的流量</span></span><br><span class="line"> client.loop_forever()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3 TCP服务端搭建</title>
      <link href="/2018/05/09/thesis-6-3/"/>
      <url>/2018/05/09/thesis-6-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="4-3-TCP服务端搭建"><a href="#4-3-TCP服务端搭建" class="headerlink" title="4.3 TCP服务端搭建"></a>4.3 TCP服务端搭建</h4><p>&emsp;TCP通信要明白的“三次握手”，“四次挥手”在前面章节以详细说明了，其实在实际的开发过程中，并不需要过多的去关注整个TCP通信建立的过程，你所使用的后端语言，都已经将通信的过程封装成一个个函数，只需要学会如何使用这些函数，去完成相应的功能即可。<br>基于python 语言的TCP服务器搭建，一般分为一下几个步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块包From socket import * </span></span><br><span class="line"><span class="comment">#创建sockettcp_server_socket = socket(AF_INET,SOCK_STREAM) # 本地信息address=(&#x27;&#x27;,8000) </span></span><br><span class="line"><span class="comment"># 绑定 </span></span><br><span class="line">tcp_server_socket.bind(address)</span><br><span class="line">tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line">client_socket,clientAddr=tcp_server_socket.accept()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">recv_data = client_socket.recv(<span class="number">1024</span>)  <span class="comment"># 接收1024个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;接收到的数据为:&#x27;</span>, recv_data.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line">client_socket.send(<span class="string">&quot;thank you !&quot;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>)) <span class="comment"># 向客户端发送数据</span></span><br><span class="line"><span class="comment"># 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接client_socket.close()</span></span><br></pre></td></tr></table></figure><p>&emsp;执行上述代码，可以创建个简单的TCP 服务端，但是该服务端是单线程的，也就是说这个服务端启动后，同一时间如若有多个客户端同时访问，只会一个一个进行处理，前面的没有释放连接，后面的连接就只能等待。这是很致命的，对于单线程的服务端，不及时释放，就会影响到其他客户端访问。所以，在实际应用中，TCP服务端都做的是多线程的，可以同时处理多个客户端的请求。<br>#####多线程TCP服务端设计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 导入模块包</span></span><br><span class="line"> <span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"> <span class="keyword">import</span> json</span><br><span class="line"> <span class="keyword">import</span> threading</span><br><span class="line"> <span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br><span class="line"> <span class="keyword">import</span> datetime</span><br><span class="line"> socket_serverlist=[]</span><br><span class="line"><span class="comment"># 发送套接字</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">send_socket</span>(<span class="params">client_socket</span>):</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&quot;PLEASE INPUTE&quot;</span>)</span><br><span class="line">        client_socket.send(data.encode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 接收处理套接字内容，并存入mysql数据库</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">recv_socket</span>(<span class="params">client_socket,cs1,conn</span>):</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r_data = recv_data.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">            j_data = json.loads(r_data)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(f)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;recv_data is:%s&#x27;</span> % r_data)</span><br><span class="line">        now_time=datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        mac=j_data[<span class="string">&#x27;addr&#x27;</span>]</span><br><span class="line">        name=<span class="string">&quot;mesh_&quot;</span>+mac[<span class="number">12</span>:<span class="number">14</span>]+mac[<span class="number">15</span>:<span class="number">17</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;name is %s&quot;</span>%name)</span><br><span class="line">        date=<span class="built_in">str</span>(j_data[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">sql=<span class="string">&#x27;insert into device_history_data values (&quot;0&quot;,&quot;&#x27;</span>+name+<span class="string">&#x27;&quot;,&quot;&#x27;</span>+mac+<span class="string">&#x27; &quot;,&quot;&#x27;</span>+date+<span class="string">&#x27; &quot;,&quot; &#x27;</span>+ now_time+<span class="string">&#x27;&quot;)&#x27;</span></span><br><span class="line">        count = cs1.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            client_socket.send(r_data.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;send_data is:  COMD ok&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(threading.active_count())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> client_socket.close()</span><br><span class="line"> <span class="comment">#创建多线程</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">creat_socket</span>(<span class="params">tcp_server_socket,cs1,conn</span>):</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;waite client onload&quot;</span>)</span><br><span class="line">        client_socket, clientAddr = tcp_server_socket.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;client ID:%s&quot;</span> % <span class="built_in">str</span>(clientAddr))</span><br><span class="line">        client_socket.settimeout(<span class="number">10</span>)</span><br><span class="line">        t = threading.Thread(target=recv_socket, args=(client_socket, cs1,conn))</span><br><span class="line">        socket_serverlist.append(t);</span><br><span class="line">        t.start()</span><br><span class="line">        <span class="built_in">print</span>(socket_serverlist)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#主函数</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    tcp_server_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">        <span class="comment">#绑定服务器ip，端口</span></span><br><span class="line">        address = (<span class="string">&#x27;&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">    tcp_server_socket.bind(address)</span><br><span class="line">        <span class="comment">#连接mysql数据库</span></span><br><span class="line">conn = connect(host=<span class="string">&#x27;192.168.1.128&#x27;</span>, port=<span class="number">3306</span>, database= <span class="string">&#x27;mesh_device _data&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>， password=<span class="string">&#x27;mysql&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"> cs1 = conn.cursor()</span><br><span class="line"> tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line">        <span class="comment">#创建多线程</span></span><br><span class="line">creat_socket(tcp_server_socket,cs1,conn)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2 搭建开发环境</title>
      <link href="/2018/04/28/thesis-6-2/"/>
      <url>/2018/04/28/thesis-6-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="4-2-搭建开发环境"><a href="#4-2-搭建开发环境" class="headerlink" title="4.2 搭建开发环境"></a>4.2 搭建开发环境</h4><p>&emsp;选用腾讯云、百度云、阿里云任何一家的云服务器作为开发主机，三大运营商为了资助高校人才培养，占领校园市场，都有针对校园用户的低价套餐，只需通过校园认证后，就可以购买到10元一个月学生套餐，当然服务器的配置也就是最低配置了。各个运营商之间稍有差异，具体配置大都为：单核CPU、2G运存、40G磁盘、1Mbps带宽，作为日常开发学习，也足够了。<br>&emsp;这里我选用腾讯云的服务器作为本设计的开发平台，购买服务器的时候，系统会让选择预装的操作系统，操作系统选择通常选用自己熟悉的linux系统就可以，不同的linux系统只是操作指令稍微有些不同，性能方面相差不大，没有好坏之分。当然预装系统是可以选用windows的，但个人感觉windows环境下做后端服务器应用的开发很不方便，所以还是推荐使用linux系统来完成开发任务，在后续的开发过程中，我使用的是Centos7.5操作系统。因为购买的服务器是运营商提供的，我们接下来的开发都是通过远程链接到服务器上进行的，所以运营商会让你选择是否购买公网IP，当然学生用户会免费赠送公网IP的，这里不需要过多关注。要注意的是，运营商会推荐购买域名，这是要另外收费的。在做网站开发的时候，通常需要申请一个域名。域名要通过DNS服务器把服务器的公网IP与申请的域名做个映射，网站开发完成后在浏览器地址栏输入域名就可以访问到你的服务器。因涉及到备案，数字证书等问题，是一个比较复杂的过程，在后续章节会详细介绍网站搭建过程。<br>购买完成后，系统会分配一个公网IP，通过SSH的方式，可以登陆到云服务器上去。常用的SSH软件很多，SecureCRT、putty、Xshell等这里选用SecureCRT。打开SecureCRT输入云服务器公网IP，用户名和密码后，即可连接上服务器。<br>&emsp;拿到服务器后，我们通常对服务器进行一些简单设备，比如重新设置密码，跟换镜像源、创建个用于开发的子账号等。linux系统默认的镜像服务器在国外，在国内下载软件会遭到防火墙拦截，因此需要将镜像源跟换为国内服务器地址。在实际开发中往往需要创建修改系统根目录下的文件，如果使用root用户进行，很容易因误操作造成系统崩溃，一般会创建子用户，使用子用户进行操作，子用户在操作系统文件时会请求授权，这样能避免误操作的发生。<br><img src="./1.png" alt="Alt text"><br>因为后续的开发主要以Python语言为主，Centos7.5版本的linux系统是预装的Python版本是2.7版本，我使用的开发环境为Python3，所以需要安装Python3开发环境。步骤如下：<br>1.在“/usr/local/”路径下创建名为“Python3”的文件夹，用了存放Python3安装文件。<br>     mkdir /usr/local/python3<br>2.进入刚创建的Python3文件夹中。<br>     cd /usr/local/python3<br>3.通过wget命令从官网下载python3的安装包。<br>     wget   <a href="https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz">https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz</a><br> 4.解压“Python-3.6.3.tgz”安装包<br>     tar -xvf Python-3.6.3.tgz<br>5.解压完成后会在当前目录下生成名为“Python-3.6.3”的文件夹，用cd命令进入文件夹中。<br>     cd Python-3.6.3/<br> 6.进入文件后，运行配置文件。<br>     ./configure<br>7.配置完成后，执行编译命令<br>     Make<br>8.编译正常后，执行安装命令<br>     Make install<br>到此，python3就安装完成了，后面会使用python3完成TCP、http服务器的开发。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1服务器设计</title>
      <link href="/2018/04/20/thesis-6-1/"/>
      <url>/2018/04/20/thesis-6-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第四章-后端服务器搭建"><a href="#第四章-后端服务器搭建" class="headerlink" title="第四章 后端服务器搭建"></a>第四章 后端服务器搭建</h3><h4 id="4-1服务器设计"><a href="#4-1服务器设计" class="headerlink" title="4.1服务器设计"></a>4.1服务器设计</h4><p>&emsp;服务器作为物联网智能家居系统的核心，不仅是起到连接各个采集控制终端设备的作用，对于数据处理，控制决策，人机交互等涉及大数据处理，以及数据可视化、逻辑控制的操作，也是由服务器来承担的。因此服务器在整个控制系统中扮演着重中之重的角色。<br>&emsp;服务器可以从组成上大致分为两部分：服务器物理机，应用服务器。服务器物理机就是由CPU、内存、磁盘、总线等组成，和通用计算机类似的物理机。而应用服务器，就是文章上述提到的针对应用程序搭建的TCP、MQTT、TCP、UDP等运行在物理机上的服务器软件。因此，搭建一台基于物联网的智能家居服务器，也要同时具备硬件和软件两个部分。虽然普通的个人电脑可以充当服务器硬件的角色，但是实际的运行性能和专业的服务器仍然存在不小的差距。然而专业的服务器价格昂贵，需要定期维护，且功耗大，单电费也是一笔不小的开支。所以对于个人或者前期测试系统的开发，一般会选用购买云服务器，来搭建测试服务器。当然，云服务器环境也可以作为正式环境来使用。那么，何为云服务器？云服务器是由第三方运营商提供的一种服务，第三方运营商将物理服务器通过租用的方式，把服务器使用权交给用户，用户通过网络可以远程的操作管理所租用的服务器，物理机的运行维护，由运营商来承担，用户只需完成应用软件的设计，实现控制系统功能即可。<br>&emsp;本设计中会搭建三种服务器，分别为TCP服务器，MQTT服务器，以及HTTP服务器。使用TCP服务器构建传感器数据采集网络，对传感器上传的数据进行过滤后存入数据库。使用MQTT服务器构建物联网设备控制网络，MQTT的消息机制，方便设备间联动控制以及异常状态快速反应。HTTP服务器作为数据可视化后端服务器，将数据库内的环境数据读取后，交给前端网页渲染，实现环境数据的可视化。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2硬件程序设计</title>
      <link href="/2018/04/10/thesis-5-2/"/>
      <url>/2018/04/10/thesis-5-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="3-2-程序设计"><a href="#3-2-程序设计" class="headerlink" title="3.2  程序设计"></a>3.2  程序设计</h3><p>&emsp;硬件设备程序要根据硬件电路进行设计，对于数字信号控制的外围设备，不论选用哪种单片机，它的控制方式包括控制程序都几乎一样，单片机控制数字量输入输出是最基本的操作，所以这里就不在赘述。本节主要是针对特殊设备驱动、控制进行驱动设计，以及常用的I2C、SPI、usart等协议的实际应用。在硬件电路设计时提出两种控制方案，值得注意的是在这两种方案中都用到了ESP8266模块，但在不同方案中esp8266充当的角色是不同的，在MCU+ESP8266方案中ESP8266作为wifi模块使用，只负责数据传输，设备联网。在单独使用ESP8266实现控制的方案中，ESP8266作为控制器使用，可对外围传感器进行直接控制，且也保留了作为wifi模块的所有功能。前者与后者相比，前者开发简单方便，后者开发难度稍大。    </p><h4 id="3-2-1-ESP8266作WIFI模块"><a href="#3-2-1-ESP8266作WIFI模块" class="headerlink" title="3.2.1 ESP8266作WIFI模块"></a>3.2.1 ESP8266作WIFI模块</h4><p>&emsp;ESP8266一般情况下通常用作wifi模块使用，所以esp8266模组出厂就内置了AT固件包，买回来的时就能直接使用。那么，什么是AT固件包呢？AT固件包就是AT指令的集合，MCU通过串口向esp8266模组发送“AT指令”，就可以配置、操作ESP8266模组，实现网络配置，数据传输等功能.<br>“AT指令”语句结构简单，指令都以字母“AT”开头，以回车结束，广泛的应用在通信模组与单片机信息交互的场合。“AT指令”是通过单片机串口发给ESP8266 WIFI模组的，默认串口通信格式为，8位数据位，1个停止位，无奇偶校验，无流控，波特率默认115200bps。<br><img src="./5.png" alt="Alt text"><br>&emsp;单片机与ESP8266进行连接时要注意，单片机的串口TXD与ESP8266模组的RXD连接，单片机的RXD要与模组的TXD连接，模组正常工作时要将reset引脚（GPIO16）置为高电平，将CH_PD使能引脚置为高电平，ESP8266模组才能正常工作。<br><img src="./6.png" alt="Alt text"><br>&emsp;单片机与ESP8266模组连接后，就可以通过AT指令来控制ESP8266实现一些功能了，为了方便测试调试联网功能，网络部分的程序会使用USB转TTL模块直接连接ESP8266模组和电脑，使用电脑串口来代替单片机串口与ESP8266通信，方便快速开发，迭代网络部分的程序。<br><img src="./7.png" alt="Alt text"><br>&emsp;基础的AT指令，只是控制ESP8266模组，完成复位、重置、开启关闭低功耗模式，配置串口信息，读取模组信息、测试模组状态等常规操作，对于WIFI联网方面的功能，就要使用WIFI功能块中的指令。<br><img src="./8.png" alt="Alt text"><br>&emsp;完成模块联网，并与服务器建立连接是一个相对复杂的过程，对于上图所示的WIFI功能块中的AT指令，主要用于配置网络环境，使ESP8266模组与无线网关建立连接，要注意的是ESP8266是2.4G的wifi模块，所以它不能与5G的wifi信号建立连接。<br>&emsp; ESP8266模块与局域网或广域网中的TCP、MQTT、HTTP等服务器通信时，需要使用TCP/IP功能块中的AT指令进行配置。TCP/IP功能块中的常用指令如下所示。<br> <img src="./9.png" alt="Alt text"><br>ESP8266作为client连接到TCP server：<br>    设置 WiFi 模式:  AT+CWMODE=3<br>    连接无线网关（路由器）： AT+CWJAP=”SSID”, “password”<br>    查询设备 IP 地址：AT+CIFSR<br>    ESP8266 连接到 TCP server: AT+CIPSTART=”TCP”, “192.168.3.116”, 8080<br>    发送数据：AT+CIPSEND=4<br>    接收数据无需配置，接收到数据格式为：+IPD, n: xxxxxxxxxx<br>&emsp;在连接TCP server时，若服务器处于局域网内，则ESP8266模组要与TCP服务器处于同一个网段内，执行查询设备IP地址后，若IP与TCP服务器不在同一网段，需调用“AT + CIPSTA_CUR”将IP地址配置到同一网段即可正常连接。若TCP服务器处于外网，则不需要关系IP地址问题。上述代码执行正确执行完后，就可以使用ESP8266和TCP服务器互发消息，发送的消息内容只需通过单片机的串口传给ESP8266模块，就会自动发送给服务器。同样，ESP8266模块接收的来自服务器的消息，也会通过串口返回给单片机，单片机只需要设置好串口中断，及时从串口缓存中取数据即可。</p><h4 id="3-2-2-ESP8266作控制器"><a href="#3-2-2-ESP8266作控制器" class="headerlink" title="3.2.2 ESP8266作控制器"></a>3.2.2 ESP8266作控制器</h4><p>&emsp;ESP8266内置一块控制器，通过编程、编译，重新烧写固件就可以实现单片机控制读取外围设备数据的功能。乐鑫、安信可都有推出的专门用于用户二次开发的IDE编程环境，当然也提供了linux环境下的开发工具链，对于SOC类芯片的开发，最好在linux环境下进行，linux下不管是开发工具，还是开发过程都很友好，且编译、下载都很快速方便。当然，在linux环境下开发，首先要熟悉linux环境下常规的操作，且linux下几乎很少用到图形化的开发工具，从一开始的编写代码，到编译、调试、烧写都在命令行中完成，使得开发门槛有些高，这可能成了大多数开发者选用windows开发环境的主要原因。但是很不巧的是windows环境下编写ESP8266程序，官方给出的开发环境也是兼容的UNIX环境，常用的操作指令与linux命令几乎一致，且也是在命令行下操作。虽然官方工具包只能在linux，Unix环境下运行，但是也并非没有办法脱离命令行来开发ESP8266，官方考虑到用户群体不同，开发经验也参差不齐，在当前很热门的Arduino开发平台上对ESP8266模组进行了适配。用户只需在arduino ID中编写程序，调用封装好的函数就可以实现对外围设备进行数据读取控制，以及WIFI控制等功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ESP8266作为client连接到MQTT server：</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">setup_wifi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WiFi.<span class="built_in">begin</span>(wifiSSID.<span class="built_in">c_str</span>(), wifiPASS.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">while</span> (WiFi.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">          <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">          Serial.<span class="built_in">println</span>(WiFi.<span class="built_in">status</span>());</span><br><span class="line">          Serial.<span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">//连接MQTT服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (!client.<span class="built_in">connected</span>()) &#123;</span><br><span class="line">            Serial.<span class="built_in">print</span>(<span class="string">&quot;Attempting MQTT connection...&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (client.<span class="built_in">connect</span>(sbid, cpid, jqxx)) &#123;</span><br><span class="line">              Serial.<span class="built_in">println</span>(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">              client.<span class="built_in">subscribe</span>(<span class="string">&quot;controlmyhome&quot;</span>);<span class="comment">//订阅设备控制</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             Serial.<span class="built_in">println</span>(<span class="string">&quot;MQTT Login   Fail&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//订阅消息回调</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span>* topic, byte* payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;Message arrived [&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(topic);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;] &quot;</span>);</span><br><span class="line">      <span class="comment">//判断订阅主题设置GPIO</span></span><br><span class="line">      String data;</span><br><span class="line">      data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        data = data + (<span class="keyword">char</span>)payload[i];</span><br><span class="line">      &#125;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;data:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(data);</span><br><span class="line">      <span class="comment">//判断第三方web发送格式：&#123;&quot;switch&quot;:&quot;Open&quot;&#125;</span></span><br><span class="line">      StaticJsonBuffer&lt;<span class="number">200</span>&gt; jsonBuffer;</span><br><span class="line">      JsonObject&amp; root = jsonBuffer.<span class="built_in">parseObject</span>(data);</span><br><span class="line">      <span class="keyword">if</span> (!root.<span class="built_in">success</span>()) &#123;</span><br><span class="line">        Serial.<span class="built_in">println</span>(<span class="string">&quot;Json parseObject() failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;通过调用setup_wifi()函数将wifi的名称和密码作为参数传入，使ESP8266模块联上WIFI，调用client.setServer(mqtt_server, port)函数，传入MQTT server的IP地址和端口号。接着调用reconnect()函数连接到MQTT服务器，在client.connect（）函数中填入鉴权信息，用作设备验证登陆，使用client.subscribe(“Topic”)函数，订阅主题。使用内置client.setCallback(callback)函数设置回调函数为callback函数，接收到的主题消息都在callback函数中进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 硬件平台程序设计</title>
      <link href="/2018/03/27/thesis-5-1/"/>
      <url>/2018/03/27/thesis-5-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第三章-硬件平台程序设计"><a href="#第三章-硬件平台程序设计" class="headerlink" title="第三章 硬件平台程序设计"></a>第三章 硬件平台程序设计</h3><h4 id="3-1-通信协议确立"><a href="#3-1-通信协议确立" class="headerlink" title="3.1 通信协议确立"></a>3.1 通信协议确立</h4><p>&emsp;常见的通信协议有TCP、UDP、MQTT、HTTP协议等，硬件层协议要与后端服务器匹配才能完成通信。硬件层协议要充分考虑单片机运行速度，以及内存大小，选择合适的通信协议有利用提高系统稳定性，保障数据传输的安全性，减少传输过程中出错概率。</p><h4 id="3-1-1-TCP协议"><a href="#3-1-1-TCP协议" class="headerlink" title="3.1.1 TCP协议"></a>3.1.1 TCP协议</h4><p>&emsp;TCP协议全称: TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。传输控制协议,就是要对数据的传输进行控制.<br>TCP协议主要任务是建立应用程序之间信息通信。应用程序要想建立通信，首先其中一方会主动发送一个请求，申请建立通信，这个请求会被发送到接收方对应的IP地址。当接收方收到请求后双方会执行“握手”流程，确保双方通信稳定、安全的建立。TCP通信建立后，两个应用程序可以实现全双工的信息交流。<br><img src="./1.png" alt="Alt text"><br>&emsp;端口号：计算机上可以运行很多TCP应用程序，同一台计算机上运行的所有TCP应用程序它们的IP地址是相同的，那么，如何区分这些应用程序？如何保证数据能被指定的应用程序接收，端口号的作用就体现出来了。同一台计算机上所有的TCP应用程序，它们都有着自己唯一的端口号，端口号类似与通道号，TCP应用程序通过IP地址+端口号，可以与同一计算机上不同的TCP应用程序通信，也可以与不同计算机上的TCP应用程序通信。<br>&emsp;序号：使用TCP协议进行数据通信时，如若发送数据量大，TCP会将报文分段发送，但是在数据传输过程中，受网络状况，干扰信号的影响。即使发送端按找严格的时间顺序进行报文段的发送，但接收端往往接收到的数据顺序并非与发送端发送顺序一致。因此，序号的作用是在多段数据发送时，用了区分数据段的先后顺序，使得技术数据到达目标主机时的顺序不同，目标主机也能通过序号对数据进行处理，得到与发送端一模一样的数据。那么，为什么TCP协议要对大数据量分段发送呢？首先要明白，数据在传输过程中，难免因网络环境，传输线路的外部干扰，造成数据出错、丢失，所以接收端每收到一组数据都会对其校验，倘若传输过程数据出错，就会触发数据重传。数据量多大，单次传输很浪费时间，如果发送数据错误，哪怕是只有一个字节，那么重新传输又得重头开始传，导致出错时重传很是浪费时间。分段传输，出错只会重传出错的数据段，能很好的减少出错重传时时间的浪费。<br>&emsp;确认号：用于确认有多少数据段被目标主机接收，确认号等于按照顺序接收到的最后一个数据段的序号加1。<br>数据偏移：从TCP报文格式中可以得知，首部含有可选项，可选项将会导致TCP首部的长度发送变化。数据偏移是指TCP报文的数据段，距离TCP报文起始地址的距离，也就是TCP首部的长度。数据偏移占用4bit，也就是最大值为“1111”，所以首部最大占用60字节（即15*32/8）。<br>&emsp;保留位：暂时保留，无具体功能，可以忽略，占用6bit，默认全部置“0”。<br>&emsp;URG(紧急)：为“1”时有效，用于开启、关闭紧急指针功能。<br>&emsp;ACK（确认）：为“1”时，使能确认号字段。<br>&emsp;PSH(推送)：置为“1”时，启动TCP推送功能，在目的主机接收端PSH为1的报文是，会尽快的推送给应用程序，而不是放在缓存中等待缓存填满后向上交付。<br>&emsp;RST(复位)：用于复位当前TCP连接。<br>&emsp;SYN（同步）：用于TCP“三次握手”建立连接时有效。SYN为“1”，ACK为“0”，则表明该字段为请求段。<br>&emsp;FIN（完成）：当数据传输完成时FIN置为“1”，表示数据传输完成，用于释放当前连接。<br>&emsp;窗口：用来告知发送端，接受端缓存的大小，从而控制发送端发送的速率。<br>&emsp;校验和：用于校验整个TCP报文，判断传输过程是否出错。<br>&emsp;紧急指针：指向紧急数据最后字节的序号。<br>&emsp;选项：包括“时间戳”，“窗口扩大因子”等选项。最大长度40字节。<br>&emsp;数据：TCP传输数据存放的位置，可选字段，无数据发送可为空。<br>&emsp;应用程序使用TCP协议与服务器建立连接时，会执行“三次握手”流程，当三次握手成功后才能正常的传输数据。那么，何为“三次握手”？其实三次握手，可以理解为应用程序与TCP服务器进行的三次对话。应用程序与TCP服务器通信，那么应用程序就是客户端，TCP服务器就是服务端。客户端要想与服务器建立通信，首先客户端要向服务器发送建立连接请求，此为第一次“握手”。服务器收到客户端的建立连接请求后，会向客户端发送应答信号，表示收到连接请求，此为第二次“握手”。当客户端收到服务器应答信号后，会返回响应信号，告诉服务器已经收到数据，此为第三次“握手”。在完成三次握手后，客户端与服务器才执行正常数据通信。<br><img src="./2.png" alt="Alt text"><br>&emsp;客户端与服务器传输数据结束后，要执行断开连接的动作，此时，会执行“四次挥手”来断开当前的连接。具体过程如下：当客户端发送完数据后，会主动发送释放连接的报文，此为第一次“挥手”。当服务器收到客户端释放连接的报文后，会给客户端返回一个确认报文，此时客户端收到确认报文后，会进入等待终止的状态。等待服务端的释放连接的报文。此过程中服务端向客户端发送确认报文为第二次“挥手”。这是服务器主动向客户端发送释放连接的报文，并等待客户端的最后确认报文,此为第三次“挥手”。当客户端收到服务器的释放连接报文后，返回给服务器确认报文，此为第四次“挥手”。服务器在收到最后确认报文后会关闭连接。<br><img src="./3.png" alt="Alt text"></p><h4 id="3-1-2MQTT协议"><a href="#3-1-2MQTT协议" class="headerlink" title="3.1.2MQTT协议"></a>3.1.2MQTT协议</h4><p>&emsp;MQTT(Message Queuing Telemetry Transport，消息队列遥测传输)是IBM开发的一个即时通讯协议。MQTT协议客户端与服务器通信是通过消息订阅，消息发布来完成，MQTT不论是客户端还是服务器都可以发布或订阅主题。发布主题时，所有订阅该主题的客户端都可以收到消息。客户端也可以订阅多个主题，这个过程类似与微信或者QQ的群聊，订阅主题就像加入到了群聊中，每个客户端发布的消息都会被共享。这种方式很时候物联网应用，只需发布一条消息，所有订阅的设备就能收到消息，并执行各自的处理过程，实现联动控制，设备集群的控制，解决了物联网多传感器控制流程繁琐的难题。<br><img src="./4.png" alt="Alt text"><br>&emsp;如上图所示，智能家居硬件设备采用MQTT协议进行组网通信，假定温度对应的主题为 “temperature”，除了测温设备外，所有设备都订阅了“temperature”主题，测温设备检测到室温为20摄氏度，向MQTT网络发布了“temperature：20℃”，则所有订阅“tempera- ture”主题的设备都会收到这条消息。当然若是测温设备也订阅了“temperature”主题,其自身也会收到消息。在实际应用场合中，一个智能家居控制设备，往往会关注一个或多个环境参数，这些参数的检测设备可能处于同一空间不同位置，也可能处于不同空间。比如窗帘控制设备，它需要知道室内室外的光照强度，用来判断白天黑夜，根据光强控制窗帘遮光面积。室内的检测设备和室外的并不是同一区域，要想实现数据交互，按照TCP、http或者UDP的做法，一般检测设备会与服务器连接，上传环境数据，服务器将环境数据存入数据库，当控制设备要根据环境数据来执行控制动作时，会向服务器发起查询请求，服务器通过查询数据库，将数据库内对于的数据发送给控制设备，这其实是个很耗时的过程。这时候MQTT的优点就提现出来了。用MQTT协议，检测设备发布的环境数据直接就转给了所有订阅相同主题的设备，数据存储，服务器后台就可以轻松完成。省去了控制设备获取环境数据时，服务器每次都去查询数据库的过程。且不说网络环境是否稳定，就算是响应最快的设备，网络传输也要耗费一定时间，要知道物联网控制设备，最敏感的问题就是控制延时，这是不可避免的，但是可以优化。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP8266控制系统设计</title>
      <link href="/2018/03/15/thesis-4/"/>
      <url>/2018/03/15/thesis-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="基于ESP8266控制系统设计"><a href="#基于ESP8266控制系统设计" class="headerlink" title="基于ESP8266控制系统设计"></a>基于ESP8266控制系统设计</h4><p>&emsp;ESP8266模组内置32位微控制器，一般应用场合作wifi模块使用，调用AT指令来控制模块收发数据。本节通过对ESP8266模组内的微控制器进行编程，即可作为单片机正常读取外围传感器数据。适用于低功耗场景，且占用空间小。<br><img src="./1.png" alt="Alt text"></p><ul><li>ESP8266工作模式：<br>&emsp;ESP8266支持softAP模式，station模式，softAP+station 共存模式三种。SoftAP即无线接入点，是一个无线网络的中心节点。通常使用的无线路由器就是一个无线接入点。Station即无线终端，作为无线设备与softAP建立连接。<br>&emsp;（1）ESP8266处于softAP模式：<br>ESP8266作为softAP，手机、电脑、用户设备、其他ESP8266 station接口等均可以作为station连入ESP8266，组建成一个局域网，在局域网内，所有station设备发送的信息都会通过SoftAP设备进行处理、转发，通过Station设备发送控制命令，就可以通过SoftAP设备间接控制处于同一局域网的其他Station设备。<br><img src="./2.png" alt="Alt text"><br>&emsp;（2）ESP8266处于Station模式：<br>  ESP8266作为station，通过路由器（AP）连入internet，可向云端服务器上传、下载数据。用户可随时使用移动终端（手机、笔记本等），通过云端监控ESP8266设备的状况，向 ESP8266模块发送控制指令。<br>  <img src="./3.png" alt="Alt text"><br>  （3）ESP8266 在 SoftAP + station 共存模式:<br>ESP8266支持softAP+station共存的模式，用户设备、手机等可以作为station 连入 ESP8266的softAP接口, 同时，可以控制 ESP8266的station接口通过路由器（AP）连入 internet.<br><img src="./4.png" alt="Alt text"></li></ul><h5 id="（一）传感器功能"><a href="#（一）传感器功能" class="headerlink" title="（一）传感器功能"></a>（一）传感器功能</h5><p>&emsp;以ESP8266作为控制单元，引出A0模拟量引脚，根据不同控制场景，选择搭载光敏传感器模块、PM2.5灰尘传感器、液体传感器以及红外火焰传感器等模拟量传感器。引出一路GPIO通用输入输出引脚，外接DHT11温湿度传感器。选用DHT11温湿度传感器的原因是： ESP8266-12f模块只有一路模拟量输入引脚，引脚资源紧张，选用数字式传感器更合理。所处控制场合对温湿度采集精度要求不高，且DHT11价格便宜，占用控制引脚少。</p><h5 id="（二）电量监测功能"><a href="#（二）电量监测功能" class="headerlink" title="（二）电量监测功能"></a>（二）电量监测功能</h5><p>&emsp;物联网智能家居设备，直接与电器设备相连。在特定场景下，使用者除了日常开关控制外，更想去关注电器设备运行状态以及电量信息。HLW8032是一款高精度的电能计量IC,它采用CMOS制造工艺，主要用于单相应用场合。HLW8032可以通过UART口进行数据通讯，HLW8032采用5V供电，内置3.579M晶振，8PIN的SOP封装，具有精度高、功耗小、可靠性高、适用环境能力强等优点，适用于单相两线制电力用户的电能计量。<br><img src="./5.png" alt="Alt text"><br><img src="./6.png" alt="Alt text"><br>&emsp;HLW8032具有一个简单的UART接口，采用异步串行通讯方式，允许用两个单向引脚进行数据通讯，UART接口只需要一个低成本光电藕合器，就可以实现隔离通信。UART接口以4800 bps的固定频率工作，发送数据的间隔时间是50mS，适合低速设计。<br><img src="./7.png" alt="Alt text"><br>&emsp;HLW8032 每发送一次完整数据是 24byte; 从寄存器 1(State REG)开发发送，到寄存器11(CheckSum REG)结束一组数据，一共 11 个寄存器，24 byte 数据。在 HLW8032 的电源端，应并联两个小电容，以滤除来自电网高频及低频噪声。电流信号通过锰铜电阻采样后接入HLW8032，电压信号则通过电阻网络后输入到HLW8032。PF、TX直接接入到MCU的输入端，通过公计算计算出电压有效值、 电压流效值和有功功率值的大小。<br><img src="./8.png" alt="Alt text"><br><img src="./9.png" alt="Alt text"></p><h5 id="（三）数据显示功能"><a href="#（三）数据显示功能" class="headerlink" title="（三）数据显示功能"></a>（三）数据显示功能</h5><p>&emsp;硬件控制器搭载一块0.96寸 oled屏幕。OLED的基本结构是由一薄而透明具半导体特性之铟锡氧化物(ITO)，与电力之正极相连，再加上另一个金属阴极，包成如三明治的结构。整个结构层中包括了:空穴传输层(HTL)、发光层(EL)与电子传输层(ETL)。当电力供应至适当电压时，正极空穴与阴极电荷就会在发光层中结合，产生光亮，依其配方不同产生红、绿和蓝RGB三基色，构成基本色彩。OLED的特性是自己发光，不像TFT LCD需要背光，因此可视度和亮度均高，其次是电压需求低且省电效率高，加上反应快、重量轻、厚度薄，构造简单，成本低等。<br>OLED采用SSD1306 CMOS OLED驱动芯片驱动，该芯片专为阴极oled面板设计，SSD1306中嵌入了对比度控制器，显示RAM和晶振，并因此减少外部器件和功耗。有256级亮度控制。数据/命令有3种接口可选：6800/8000串口，I2C接口和SPI接口。<br>（四）执行机构<br>&emsp;控制电器开关，依然采用继电器控制，但由于ESP8266控制方案针对单个电器进行控制的，所以继电器带的负载容量应相应增大。为了适应日常家用电器负载需求，选用SLA-5VDC-SL-A型号继电器。该继电器最大可带负载为交流 240v 30A，满足日常家用电器的用电需求。<br><strong>电路原理图：</strong><br><img src="./10.png" alt="Alt text"><br><img src="./11.png" alt="Alt text"><br><img src="./12.png" alt="Alt text"><br><img src="./13.png" alt="Alt text"><br>&emsp;在实际应用场合中，控制器是与家用电器直接接入220v交流电网的，但是控制设备的传感器、芯片，正常工作时电压等级通常为直流5v，直流3.3v，所以需要将220v交流电转化为5v和3.3v直流电压。常见的转化方式大都用变压器耦合降压，通过整流桥整流，滤波稳压，达到需要的电压等级。但是此方式电路复杂且占用空间大，为了节省空间压缩电路板的体积，使设备尽可能小巧，所以选用HLK-PM01 AC-DC电源降压模块，该电源模块能将220v交流电转化为5v直流电，且输出电压纹波低，噪声小。得到直流5v电压后经过AMS1117-3.3 直流稳压模块将5v电压稳压至3.3v。<br><img src="./14.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32F103控制系统设计</title>
      <link href="/2018/03/06/thesis-3/"/>
      <url>/2018/03/06/thesis-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="2-2-基于STM32F103控制系统设计"><a href="#2-2-基于STM32F103控制系统设计" class="headerlink" title="2.2 基于STM32F103控制系统设计"></a>2.2 基于STM32F103控制系统设计</h4><p>&emsp;硬件层选用Stm32+esp8266框架，因控制芯片引脚丰富，可以搭载更多的传感器，满足复杂环境的控制需求。以STM32F103C8T6芯片为主控芯片，通过usart串口与乐鑫公司生产的ESP8266-01模组连接，配置STM32F103芯片的通用输入输出端口为数字量输出，数字量输入，模拟量输入模式，外接继电器模组，LED灯，温湿度传感器，OLED显示屏，独立按键，存储芯片，灰尘传感器等设备。<br><img src="./1.png" alt="Alt text"></p><h5 id="硬件功能设计："><a href="#硬件功能设计：" class="headerlink" title="硬件功能设计："></a>硬件功能设计：</h5><h6 id="（一）联网功能"><a href="#（一）联网功能" class="headerlink" title="（一）联网功能"></a>（一）联网功能</h6><p>&emsp;作为物联网方面的设备， 硬件通过板载WIFI模块进行联网，模块型号为 ESP8266_01，通过串口与单片机通信，接入简单方便。出厂固件支持SoC方案及二次开发，大大降低开发成本，缩短研发周期。当然，想用其它的方式联网，也可以通过IO 口进行扩展。电路原理图如下所示：<br><img src="./2.png" alt="Alt text"></p><h6 id="（二）传感器功能"><a href="#（二）传感器功能" class="headerlink" title="（二）传感器功能"></a>（二）传感器功能</h6><p>&emsp;集成了温湿度传感器，型号为 SHT30，采用 I2C 接口，可以实时采集环境数据，上传到后端软件平台进行数据处理，以供相关功能使用，也可以通过I2C接口，扩展其它传感器。<br><img src="./3.png" alt="Alt text"></p><h6 id="（三）最小系统"><a href="#（三）最小系统" class="headerlink" title="（三）最小系统"></a>（三）最小系统</h6><p>&emsp;最小系统是STM32F103单片机能够正常运行，实现数据输入输出的最小硬件组成。使用最小系统电路方便快速搭建各种控制单元。引出芯片控制管脚，可以直接和传感器连接，快速搭建外围电路，完成硬件测试电路的构建。最小系统一般应该包括:单片机、晶振电路、复位电路。<br>&emsp;复位电路:由电容串联电阻构成, 主芯片为低电平复位，复位电路CREST端连接主芯片第7脚复位管脚，结合”电容电压不能突变”的性质,可以知道,当上电一瞬间， C2相当于通路接地，芯片自动复位，之后VDD稳定，C2相当于断路，复位端CREST一直为高电平。<br><img src="./4.png" alt="Alt text"><br>&emsp;时钟电路：主频选用12MHz晶振，时钟RTC频率选用32.768KHz．<br><img src="./5.png" alt="Alt text"><br><img src="./6.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件平台设计</title>
      <link href="/2018/03/06/thesis-2/"/>
      <url>/2018/03/06/thesis-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="硬件平台设计"><a href="#硬件平台设计" class="headerlink" title="硬件平台设计"></a>硬件平台设计</h3><h4 id="2-1-硬件平台框架设计"><a href="#2-1-硬件平台框架设计" class="headerlink" title="2.1 硬件平台框架设计"></a>2.1 硬件平台框架设计</h4><p>&emsp;&emsp;硬件平台搭建可以简单的分为三大部分：控制器，外围设备，以及驱动电路。控制器是硬件电路的核心，主要工作是与外围设备进行数据通信，控制设备运行状态。外围设备通常为传感器，显示器件，特殊功能芯片。驱动电路可以理解为控制器与外围设备连接的桥梁，只有当硬件电路满足外设驱动标准，再按照特点的通信协议编写控制程序，才能实现控制器与外围设备间正常的数据通信。<br><img src="./1.png" alt="Alt text"></p><h4 id="2-1-1-控制方案"><a href="#2-1-1-控制方案" class="headerlink" title="2.1.1 控制方案"></a>2.1.1 控制方案</h4><p>&emsp;&emsp;控制器通过I2C总线与温湿度传感器，OLED显示屏，光强传感器连接，通过I2C协议读取控制。对于一些输入输出为数字量或者模拟量的外围器件，则通过控制器的通用输入输出接口与之相连。这类器件通常为MQ系列的气体传感器，光耦驱动的继电器模组，红外灰尘传感器，火焰传感器等。作为一款物联网设备，硬件层要求必须具备局域网或广域网通信的能力，常见的通信模块有乐鑫的ESP8266 WIFI模块，GPRS 移动通信模组，2.4G射频模块（lora，zigbee等）。针对于不同的控制场合，充分考虑系统成本、控制需求，在控制器的选型上进行优化，得到两种方案。</p><ul><li>方案一：使用STM32单片机作为控制器，主要优点是控制管脚多，可外接设备丰富。缺点是硬件成本相对较高，在控制点数较少的场合，会造成硬件资源浪费。</li><li>方案二：使用ESP8266系列WIFI模组作为控制芯片，ESP8266系列模组是款高度集成的WIFI SOC(片上系统)解决方案，通过编程可以同时兼顾I/O控制和wifi数据传输，适用于控制点数较少的场合，且价格便宜。缺点是可供使用的I/O引脚数量与STM32芯片相比要少的多，不能满足大规模，多控制点位场合的控制。<h4 id="2-1-2-控制器选型"><a href="#2-1-2-控制器选型" class="headerlink" title="2.1.2 控制器选型"></a>2.1.2 控制器选型</h4></li><li>（一）STM32F103C8T6<br>&emsp;STM32F103C8T6是一个32位微控制器，采用哈佛结构设计，拥有单独的数据、指令总线，使得数据访问与取指能够同时进行，极大的提升了性能。芯片内部提供了多条总线接口，并且都可以并行工作，指令总线和数据总线共享同一内存空间。为了适应复杂应用对存储空间的需求，STM32F103C8T6 提供一个可选的 MPU，而且在需要的情况下也可以使用外部的 cache。</li><li>（二）ESP8266<br>&emsp;ESP8266-12f集成了 32 位 Tensilica 处理器、有标准数字输入输出接口、天线开关、射频 balun、功率放大器、低噪放大器、过滤器和电源管理模块等，内置的 Tensilica L106 32 位 RISC 处理器，CPU 时钟速度最高可达 160 MHz，支持实时操作系统 (RTOS) 和 Wi-Fi 协议栈。 ESP8266模组是款高度集成的WIFI SOC(片上系统)解决方案，通过编程可以同时兼顾I/O控制和wifi数据传输，适用于控制点数较少的场合，且价格便宜， 具有的省电模式适用于各种低功耗应用场景，并且工作温度范围大，能够保持稳定的性能，能适应各种操作环境。<h4 id="2-1-3-传感器选型"><a href="#2-1-3-传感器选型" class="headerlink" title="2.1.3 传感器选型"></a>2.1.3 传感器选型</h4>#####（一）温湿度传感器<br>&emsp;瑞士Sensirion 数字温度传感器SHT30建立在全新和优化的CMOSens® 芯片之上，进一步提高了产品可靠性和精度规格。SHT30提供了一系列新功能，如增强信号处理、两个独特和用户可选I2C地址、一个可编程温湿度极限的报警模式，以及高达1 MHz的通信速度.<br><img src="./2.png" alt="Alt text"><br>&emsp;通过改变选择ADDR引脚的电压，实现传感器的地址改变。默认地址是ADDR连接VSS时（ 0X44），可以修改成0X45。 SHT30工作模式如下：</li><li>（1）<strong>单次数据采集模式:</strong><br>不同命令，在重复性(高，中，低）和时钟延伸(禁止，使能）方面不同，每个数据包含一个16位温度和一个16位湿度值（按此顺序）组成。<br>传输过程如下所示：<br>&emsp;STM32发出START，并发出I2C的地址（7位）+读（1）/写（0）标志位，然后等待SHT30的ACK。<br>&emsp;发出命令高8位数据，等待SHT30的ACK。<br>&emsp;发出命令低8位数据，等待SHT30的ACK。<br>&emsp;STM32发送STOP停止通信。<br>&emsp;STM32发出START，并发出I2C的地址（7位）+读（1）/写（0）标志位，然后等待SHT30的ACK。<br>&emsp;传感器将接收读头的接收，并发送两个字节的数据（温度），接着是一个字节的CRC校验。<br>&emsp;传感器发送两个字节的数据（相对湿度），然后是一个字节的CRC校验和。每发送8位必须接受到STM32回应的ACK条件传感器才会继续发送数据。如果传感器没有接收到ACK，它就不会继续发送数据。</li><li>（2）<strong>周期性数据采集模式:</strong><br>&emsp;不同命令，在重复性(高，中，低）和数据采集频率((0.5, 1, 2, 4 &amp; 10 mps ）方面不同，每个数据包含一个16位温度和一个16位湿度值（按此顺序）组成。测量数据的传输可以通过获取数据命令来启动。在读取命令获得数据之后，数据存储器被清除。<h5 id="（二）照传感器"><a href="#（二）照传感器" class="headerlink" title="（二）照传感器"></a>（二）照传感器</h5>&emsp;BH1750FVI基于I2C通信协议的数字型光强度传感器。光强采集范围：1-65535lx，采用标准的I2C总线传输方式，BH1750读取方法：通电、设定模式、等待测量、读取数据光照强度=（读取值<em>分辨率）/（1.2</em>灵敏度）。单片机通过I2C总线向传感器发送起始信号，并向传感器发送设备地址和写信号，发送完毕，主机等待传感器应答，然后主机向从机发送内部寄存器地址，主机等待传感器应答，主机向从机发送停止，时序为：<br><img src="./3.png" alt="Alt text"></li></ul><p>&emsp; (1)发送“连续高分辨率模式”指令<br> <img src="./4.png" alt="Alt text"><br> &emsp;(2)等待第一次连续高分辨率测量（最大时间为180ms）<br> <img src="./5.png" alt="Alt text"><br>&emsp;等待完成第一次的测量（最大时间180ms），然后读取测量结果，读取BH1750的16位数据，数据为高位和低位，过程为单片机通过I2C总线向传感器发送起始信号，并向传感器发送设备地址和写信号，发送完毕，主机等待传感器应答，然后读取高位数据（15:8），并发送应答，读取高位数据（7:0），不向主机发送应答，主机停止发送信号，采集过程结束。</p><h5 id="（三）粉尘传感器"><a href="#（三）粉尘传感器" class="headerlink" title="（三）粉尘传感器"></a>（三）粉尘传感器</h5><p>&emsp;GP2Y1014AU粉尘传感器是夏普公司开发的一款光学灰尘监测传感器模块，在其中间有一个大洞，空气可以自由流过，它里面邻角位置放着红外发光二极管和光电晶体管，红外发光二极管定向发送红外，当空气中有粉尘经过坚持区域时，红外光发生漫反射，光电晶体管接收到红外光后，会使信号输出引脚电压发送变化，通过读取电压信号，从而可以计算出粉尘浓度。其属性值如下；<br>     供电电压：5-7V<br>     工作温度：-10-65℃<br>     监测最小直径：0.8μm<br>灵敏度：0.5V/（0.1mg/m3）灰尘浓度每变化0.1mg/m3，输出电压变化0.5V。<br>驱动条件：模块需要外接220uf电容，150R电阻来搭建驱动电路，电路图如下所示； LED驱动周期为10ms，LED驱动时间即脉冲宽度为0.32ms，采用时间为0.28ms，输出电压会根据单位时间通过过孔的粉尘浓度产生相应变化。<br><img src="./6.png" alt="Alt text"><br>灰尘和烟的判别方法：根据输出电平持续的时间和电平大小变化，可以推断出检出对象。通常情况下，烟是细微粒子，密度高，会扩散式的大范围漂移。而灰尘相对来说是一个个大的颗粒，密度要比烟低，会断断续续的经过灰尘传感器的检出区域。烟的检出电压表现为连续的高电压，而灰尘的检出电压表现为间断性的高电压。因此，只需读取一段时间内灰尘传感器的检出电压，即可通过电压趋势来分辨出污染程度，以及主要的污染物。<br><img src="./7.png" alt="Alt text"></p><h5 id="（四）气体传感器"><a href="#（四）气体传感器" class="headerlink" title="（四）气体传感器"></a>（四）气体传感器</h5><p>&emsp;气体传感器选用MQ-2系列传感器模块。MQ-2可以检测天然气、液化石油气、烟雾、酒精等，对烷烃和烟雾最敏感，模块可以输出数字信号和模拟电压，直接与单片机相连，通过调节模块上的可调电阻，可以改变输出数字信号的阀值。传感器采用二氧化锡半导体气敏材料，通过内部发热丝加热，处于200摄氏度到300摄氏度之间时，二氧化锡与空气中氧气结合，形成负离子吸附，使半导体电子密度减小，导致电阻阻值增加。晶体颗粒间界处的势垒受到烟雾浓度而变化，从而引起表面导电率变化，浓度越大，电阻越低，导电率越大，输出的模拟信号也越大。</p><h5 id="（五）火焰传感器"><a href="#（五）火焰传感器" class="headerlink" title="（五）火焰传感器"></a>（五）火焰传感器</h5><p>&emsp;远红外火焰传感器模块，用于检测室内是否存在明火，探测灵敏度可旋转可调电阻来改变，对于760~1100纳米范围内的光源比较敏感，使用5v直流电源供电。可输出数字信号和模拟信号，可直接与单片机相连，实际使用过程中应尽量远离火源安装，防止高温损毁模块，且尽量避开阳光，实际测试时发现太阳光对其影响较大。</p><h4 id="2-1-4-执行机构选型"><a href="#2-1-4-执行机构选型" class="headerlink" title="2.1.4 执行机构选型"></a>2.1.4 执行机构选型</h4><p>&emsp;本设计主要控制量为开关量，控制的设备为250v 10A以下的家用电器，所以选用继电器或继电器模组作为控制器的执行机构，继电器选用松乐SRD-05VDC-SL-C 继电器，控制端电压5v，额定电流71.4 mA，输出端可接AC 250v 10A、DC 30v 10A以下的设备。继电器是一种可控的开关器件，通常应用与二次回路，继电器主要特性是用小电流小电压控制大电流大电压，因此,用于高电压大电流负载的开关控制，起到隔离保护的作用。继电器的主要工作原理是利用电磁效应，通过给线圈通电，产生磁力吸引衔铁，使得衔铁上的动触点与静触点接触，达到开关控制的效果。<br><img src="./8.png" alt="Alt text"><br>&emsp;由于stm32，esp8266控制芯片管脚输出电压为3.3V，继电器控制电压为5V，所以需要进行电压匹配。单片机控制光耦PIN1引脚，光耦输出端通过2.2k电阻与s8050三极管基极相连，三极管串联在继电器控制回路中，通过控制三极管控制继电器的导通和关断。</p>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能家居系统语音交互设计方案</title>
      <link href="/2018/03/05/thesis-1/"/>
      <url>/2018/03/05/thesis-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;智能家居是一个较为复杂的控制系统，控制设备既要实现精准控制，又要做到快速响应，这就要求我们必须有个灵活的后端服务平台，来处理设备采集上传的数据，并精准快速的向设备发出控制指令。如何搭建一个高性能的后端服务平台？选用什么样的通信协议？硬件如何设计既能满足控制需求，又能做到价格便宜性能优越？这需要去不断探索研究。拟解决的主要科学及技术问题如下:</p><ul><li>（1）控制设备硬件设计<br>控制设备的硬件设计要和实际控制环境相适应，充分利用硬件资源，既要精确采集上传环境数据，又要果断完成控制动作。</li><li>（2）控制设备软件设计<br>控制设备如何采集上传数据，如何接收服务器的控制指令，怎样高效完成控制动作。这不仅要求硬件可靠，还要软件设计合理。软件层作为控制设备的灵魂，对控制设备性能起决定性作用。选用合适的通信协议是数据能够稳定传输的保障。</li><li>（3）后端服务器的搭建<br>后端服务器是整个控制系统的大脑，底层的控制设备要将所有环境数据，设备运行数据上传到服务器，服务器对数据进行分析后发送控制指令给控制设备。后端是整个控制系统的核心，要完成数据的接收与指令发送，要求后端服务器与底层控制设备统一通信协议，并设置数据加密解密算法，保证系统安全性。</li><li>（4）应用层软件功能设计<br>应用层软件的设计，直接体现出设备功能是否完善，设计是否合理。完善合理的功能，直接决定了用户体验。</li><li>（5）语音交互设计<br>语音控制是现代智能家居发展的方向，准确清晰的语音识别会极大的简化控制流程，带来不一样的控制体验。针对最新兴起Ai技术，利用开发平台对外的api接口，融合控制协议，赋予设备语音交互的能力。</li><li>（6）控制设备外观设计<br>根据实际电路板的大小，利用SolidWorks设计比较美观的外壳，利用3d打印技术完成设备外观的设计。</li><li>（7）系统性能优化，兼容三方控制协议<br>控制设备采用私有控制标准，在后端服务器上编写通信协议兼容框架，兼容第三方厂商的控制平台，实现设备消息互通，控制指令互通。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 智能家居系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dueros </tag>
            
            <tag> speech sounds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266多链接配置教程</title>
      <link href="/2017/08/26/esp8266-AT-setting/"/>
      <url>/2017/08/26/esp8266-AT-setting/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ESP8266多链接配置教程"><a href="#ESP8266多链接配置教程" class="headerlink" title="ESP8266多链接配置教程"></a>ESP8266多链接配置教程</h3><blockquote><p> ESP8266是一款串口wifi模块，模块内嵌 TCP/IP 协议，可以实现串口、WIFI 之间的数据传输转换传输. 模块内嵌AT指令，可以通过串口发送AT指令来操作模块。由于网上对ESP8266多连接模式配置，没有详细的教程，做物联网产品研发可能会让自己的设备同时登陆到第三方网站上获取信息，为了在获取第三方网站数据时，仍然保持与主服务器通信，这里就需要将8266配置为多链接模式.</p></blockquote><p>&emsp;<strong>为了方便本次教程用USB转串口模块为媒件，把电脑与ESP8266模块物理连接（做成产品是通过控制芯片的串口脚与模块连接）</strong>.<br><img src="./1.png" alt="Alt text"></p><ul><li><p>1.准备完毕后，在电脑端打开串口调试助手（教程所用软件由正点原子开发），选择正确的 COM 号，然后设置波特率为 115200，然后发送测试指令 ’’ AT“，返回OK则模块通信正常。如果未收到任何数据，尝试将USB转串口模块 Tx，和Rx 用杜邦线短接，再发送数据，查看是否收到同样数据，来判断是否是USB转串口模块故障。（注：初次使用USB转串口模块需要安装驱动）</p></li><li><p><img src="./2.png" alt="Alt text"></p></li><li><p>3.指令</p></li><li><p>1）设置 WIFI 模式：<br>AT+CWMODE=1           //设置为 STA 模式</p><p>响应:OK</p></li><li><p>2）重启生效<br>AT+RST<br>响应:OK</p></li><li><p>3）连接路由器<br>AT+CWJAP=”TP-LINK20E8”,”123465789” //连接的wifi名和密码<br>响应:OK</p></li><li><p>4）开启多连接模式<br>AT+CIPMUX=1<br>响应:OK</p></li><li><p>5）与服务器构建链接<br>AT+CIPSTART=0,”TCP”,”183.230.40.39”,876<br>响应:0  CONNECT         </p><pre><code> OK</code></pre></li><li><p>6）与第三方服务器构建链接<br>AT+CIPSTART=1,”TCP”,”116.62.81.138”,80<br>响应:1  CONNECT            </p><pre><code>  OK</code></pre></li><li><p>7）发送数据（0号服务器发送113个字节数据）<br>AT+CIPSEND=0，113<br>响应:OK<br>  <img src="./3.png" alt="Alt text"><br>  现在就可以向服务器发送数据了。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ESP8266 </tag>
            
            <tag> AT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ONENET EDP协议在非官方开发板上的移植</title>
      <link href="/2017/08/25/edp-transplanting/"/>
      <url>/2017/08/25/edp-transplanting/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="关于ONENET-EDP协议在非官方开发板上的移植"><a href="#关于ONENET-EDP协议在非官方开发板上的移植" class="headerlink" title="关于ONENET EDP协议在非官方开发板上的移植"></a>关于ONENET EDP协议在非官方开发板上的移植</h3><blockquote><p> EDP方式接入onenet的SDK包在onenet官网论坛资料区下载，因官方例程是基于麒麟系列的开发板编写的，麒麟用的是stm32f103系列芯片，本次以f103c8t6最小系统板为本次移植目标板，理论上移植是不需要更改任何代码的，但是麒麟座用的外部晶振是12MHz的，而市场上大部分厂家生产的开发板外部晶振为8MHz。因此需要更改一些配置参数。</p></blockquote><h4 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h4><ul><li>1.打开下载好的源码例程，双击打开工程文件</li><li><img src="./1.png" alt="Alt text"></li><li>2.在左侧找到main文件双击打开。</li><li><img src="./2.png" alt="Alt text"></li><li>3.在main文件中找到#include&lt;stm32f10x.h&gt;</li><li><img src="./3.png" alt="Alt text"></li><li>4.单击鼠标右键选择  open document “stm32f10x.h”</li><li><img src="./4.png" alt="Alt text"></li><li>5.在stm32f10x.h 文件中找到箭头所示的位置（119行），将12000000改为8000000【将外部晶振频率配置为8MHz】</li><li><img src="./5.png" alt="Alt text"></li><li>6.在左侧工程文件栏找到  system_stm32f10x.c 双击打开.</li><li><img src="./6.png" alt="Alt text"></li><li>7.找到如图所示的位置，将倍频系数改为9倍频【外部晶振8*9=72Mhz】72Mhz是stm32f103系列芯片理论上的最大运行速度.</li><li><img src="./7.png" alt="Alt text"></li><li>8.到此为止，官方例程移植完毕。编译通过后直接下载就可以在自己的板子上运行官方例程.</li><li><img src="./8.png" alt="Alt text"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Onenet </tag>
            
            <tag> EDP </tag>
            
            <tag> Stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网管家机器人零入门设计</title>
      <link href="/2017/08/25/iot-car/"/>
      <url>/2017/08/25/iot-car/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###物联网管家机器人零入门设计</p><ul><li><p>设计思路：<br>在科技迅速发展的今天，生活压力的增加，人们渴望追求更优越的生活条件，所以加班的现象越来越普遍。那么当你不在家并且家里没人的时候，如果家里失火、煤气忘关，或者说管道漏水等。如何能够实时的了解家中的情况，并且能够在最短速度内报警，把损失降低到最小，显得尤为重要。因此，萌发了做一款可移动侦测采集室内数据的智能小车。</p></li><li><p>功能介绍：<br>室内环境复杂，为了保证小车不撞到障碍。使用单片机控制超声波测距，对环境障碍进行180度探测，寻找最优路径实现避障功能。假如需要小车实现多点定点检测，那么只需规划出特殊的路线，利用红外检测路线，实现自动巡航功能。传感器采集回来的数据，由MCU简单处理后，通过网络设备无线上传到“云”服务器，用户可以在电脑端，手机端查看小车移动采集的数据。当采集回来的数据，超出正常值时，可以触发“报警”功能。搭载害气体传感器接口，烟雾粉尘传感器，可实现有害气体（煤气）泄露报警，室内粉尘检测。小车采用wifi联网，为了解决大多数非专业用户在不懂编程的情况下依然能正常使用，小车采用Airkiss技术，用户可以在手机端通过微信或者特定APP就可以实现正常配网。第三方API接入展示</p></li><li><p>功能设计：<br>鉴于智能小车行动灵活的特点，在车上搭载功能外设（如温湿度计，烟雾粉尘检测模块，有害气体传感器等设备），就可以实现灵活多点数据采集，实现多点测温，火灾预警，PM2.5空气质量分析，有害气体泄露报警等功能。 本指南以嵌入式常用传感器为例，目的为初学者提供一个较为全面开发例程。</p></li><li><p>硬件介绍：</p></li><li><ol><li>  智能小车主控以stm32f103系列MCU为例（其他芯片参考移植），这里使用中国移动麒麟座开发板进行设计（感谢中移硬件赞助）。<br><img src="./1.jpg" alt="Alt text"></li></ol></li><li><p>麒麟座采用stm32f103ret6芯片为主控芯片，搭载了GSM模块 WiFi模块和温湿度传感器，角度传感器等部件，是一款功能较为齐全的硬件开发平台，出于尽可能丰富外设，做一款较完善的教程的考虑，使用麒麟开发板可以节约空间，方便添加跟多外设。</p></li><li><p>2.使用E18-D80NK 红外接近开关，用于对障碍物进行检测，触发中断执行避障机制。<br><img src="./2.jpg" alt="Alt text"></p></li><li><p>3.使用PM2.5传感器 GP2Y1014AU粉尘传感器，用于对空气中大于0.8um的颗粒物浓度进行检测。<br><img src="./3.jpg" alt="Alt text"></p></li><li><p> 4.夏普光学灰尘传感器（GP2Y1014AU0F）在检测非常细的颗粒，如香烟烟雾，是特别有效的，并且是常用的空气净化器系统。该装置中，一个红外发光二极管和光电晶体管，对角布置成允许其检测到在空气中的灰尘反射光。传感器中心有个洞可以让空气自由流过，定向发射LED光，通过检测经过空气中灰尘折射过后的光线来判断灰尘的含量。这里通过读取输出脚的模拟电压来判读颗粒浓度，用到stm32 内部ADC转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************************</span></span><br><span class="line"><span class="comment">      ADC1初始化程序  PB1口用于LED信号触发</span></span><br><span class="line"><span class="comment">*************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Adc_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"><span class="built_in">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOA | RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOB  , ENABLE );</span><br><span class="line"><span class="built_in">RCC_ADCCLKConfig</span>(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin =GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<span class="comment">//</span></span><br><span class="line"><span class="built_in">GPIO_Init</span>(GPIOA, &amp;GPIO_InitStructure); <span class="comment">//</span></span><br><span class="line"><span class="built_in">ADC_DeInit</span>(ADC1); <span class="comment">//</span></span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  <span class="comment">//</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = ENABLE;  <span class="comment">//</span></span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode =DISABLE; <span class="comment">//</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; <span class="comment">//ADC</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;  <span class="comment">//</span></span><br><span class="line"><span class="built_in">ADC_Init</span>(ADC1, &amp;ADC_InitStructure);  <span class="comment">//</span></span><br><span class="line"><span class="built_in">ADC_Cmd</span>(ADC1, ENABLE);  <span class="comment">//</span></span><br><span class="line"><span class="built_in">ADC_ResetCalibration</span>(ADC1);  <span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">ADC_GetResetCalibrationStatus</span>(ADC1)); <span class="comment">//</span></span><br><span class="line"><span class="built_in">ADC_StartCalibration</span>(ADC1);  <span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">ADC_GetCalibrationStatus</span>(ADC1)); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line"><span class="built_in">GPIO_Init</span>(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"><span class="built_in">GPIO_SetBits</span>(GPIOB, GPIO_Pin_1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">得到 ADC单通道多次平均值</span></span><br><span class="line"><span class="comment">ch=通道 S为规则序列 time=n次读取求平均值</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="function">u16 <span class="title">Get_Adc_Average</span><span class="params">(u8 ch,u8 s,u8 times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> temp_val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> pm;</span><br><span class="line">        u8 t;</span><br><span class="line">        u8 z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;times+z;t++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">GPIO_SetBits</span>(GPIOB, GPIO_Pin_1 );        </span><br><span class="line">                <span class="built_in">GPIO_ResetBits</span>(GPIOB, GPIO_Pin_1);        </span><br><span class="line"></span><br><span class="line">                <span class="built_in">delay_us</span>(<span class="number">40</span>);        </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">Get_Adc</span>(ch,s)&gt;<span class="number">300</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        temp_val+=<span class="built_in">Get_Adc</span>(ch,s);</span><br><span class="line">           &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        z++;</span><br><span class="line">                        <span class="keyword">if</span>(z&gt;<span class="number">100</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">delay_us</span>(<span class="number">280</span>);</span><br><span class="line">  <span class="built_in">GPIO_SetBits</span>(GPIOB, GPIO_Pin_1 );        </span><br><span class="line">        <span class="built_in">delay_us</span>(<span class="number">9680</span>);</span><br><span class="line">        &#125;</span><br><span class="line">temp_val=temp_val/times;</span><br><span class="line"><span class="keyword">return</span> temp_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5.模块 MQ-5液化气天然气 城市煤气传感器模块：检测燃气是否泄露<br>MQ-5有两个输出信号脚，一个是数字输（0,1）另一个是模拟输出，数字输出可以通过调节灵敏度来设置物理阀值，相对模拟输出来说 数字输出简单，可直接通过MCU端口检测，但数字输出不精确不直观，本次仍然以模拟信号进行ADC转化，通过程序判断具体燃气浓度，具体ADC配置思路同上。通过串口调试得到的数据如下：<br><img src="./5.png" alt="Alt text"></p></li><li><p>6.火焰传感器模块 火源探测模块 ：用于检测室内是否有明火.该模块也有数字信号输出脚和模拟信号输出脚，但由于stm32f103只有3个ADC,火焰检测采集模拟量意义不大，所以直接用的是数字信号输出脚，将其配置成外部中断。也可以不用中断直接检测引脚电压来判断是否有明火。<br><img src="./7.jpg" alt="Alt text"></p></li><li><p>7.SPI接口的 oled液晶显示屏:Oled显示屏直接使用厂家提供的官方驱动源码就行，没必要去研究它具体寄存器操作方式。我们只需学会使用IIC协议 或SPI协议能给屏幕发送指令就可以了。具有协议不在赘述，网上有很多，而且协议是固定通用的。<br><img src="./8.jpg" alt="Alt text"></p></li><li><p>8.RCWL-0516 微波雷达感应开关模块:用来进行人体感应，在设备开启离家模式时，如果感应到人，则会触发报警。<br><img src="./10.png" alt="Alt text"><br><img src="./9.jpg" alt="Alt text"></p></li><li><p>9.串口控制插卡SD卡语音模块：用于语音播报<br><img src="./11.jpg" alt="Alt text"><br><img src="./12.png" alt="Alt text"><br><img src="./13.png" alt="Alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart1_Init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> baud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         GPIO_InitTypeDef gpioInitStruct;</span><br><span class="line">        USART_InitTypeDef usartInitStruct;</span><br><span class="line">        NVIC_InitTypeDef nvicInitStruct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义： uint8_t stop[]={0x7e,0x03,0x1e,0x1d,0xef,0x00};  //停止命令<br>串口输出： printf（stop）；</p></li></ul><p><strong>注：前提是串口重定义过，才能使用printf函数。（网上搜索串口重定义的相关知识，）    否则 直接使用stm32f10x标准库里面的USART_SendData();函数进行逐个字节输出.</strong></p><ul><li>10 .舵机：一种角度电机，可以精确控制转动角度:舵机通过控制器发送不同占空比的PWM来改变它转动的角度，每个角度对于一个特定的频率的PWM，关于stm32  pwm的配置如下.<br><img src="./14.jpg" alt="Alt text"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM4_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                          </span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        TIM_TimeBaseInitTypeDef  </span><br><span class="line">        TIM_TimeBaseStructure;</span><br><span class="line">        TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="built_in">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_TIM4, ENABLE);       </span><br><span class="line">        <span class="built_in">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOB  |      RCC_APB2Periph_AFIO, ENABLE);  </span><br><span class="line">        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  </span><br><span class="line">        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;</span><br><span class="line">        <span class="built_in">GPIO_Init</span>(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">        TIM_TimeBaseStructure.TIM_Period = arr;</span><br><span class="line">        TIM_TimeBaseStructure.TIM_Prescaler =psc;</span><br><span class="line">        TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>;</span><br><span class="line">        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line">        <span class="built_in">TIM_TimeBaseInit</span>(TIM4, &amp;TIM_TimeBaseStructure);</span><br><span class="line">        TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;</span><br><span class="line">        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">        <span class="built_in">TIM_OC3Init</span>(TIM4, &amp;TIM_OCInitStructure);  </span><br><span class="line"></span><br><span class="line">        TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;</span><br><span class="line">        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">         <span class="built_in">TIM_OC4Init</span>(TIM4, &amp;TIM_OCInitStructure);</span><br><span class="line">        <span class="built_in">TIM_OC3PreloadConfig</span>(TIM4, TIM_OCPreload_Enable);</span><br><span class="line">        <span class="built_in">TIM_OC4PreloadConfig</span>(TIM4, TIM_OCPreload_Enable);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>通过库标准函数改变舵机转动角度：TIM_SetCompare3(TIM4,1870);                                                          TIM_SetCompare4(TIM4,1880)；</li><li><ol start="11"><li>直流电机驱动模块：模块用于驱动TT马达，输入信号同样是PWM  配置方式与舵机相同，操作方式如上图所示。选用这块模块优点 是芯片模块比晶体管模块发热小，缺点是占用控制芯片管脚多（4路PWM)<br><img src="./16.jpg" alt="Alt text"><br><img src="./15.jpg" alt="Alt text"></li></ol></li><li>12.超声波测距模块</li><li>采用IO触发测距，给至少10us的高电平信号;</li><li>模块自动发送8个40khz的方波，自动检测是否有信号返回；</li><li>有信号返回，通过IO输出一高电平，高电平持续的时间就是<br>超声波从发射到返回的时间．测试距离=(高电平时间*声速(340M/S))/2; <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超声波测距用到stm32定时器输入捕获功能配置过程如下：</span></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">初始化定时器2为捕获模式</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_Cap_Init</span><span class="params">(u16 arr,u16 psc)</span></span></span><br><span class="line"><span class="function"></span>&#123;               </span><br><span class="line">        TIM_ICInitTypeDef  TIM2_ICInitStructure;</span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">          NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">        <span class="built_in">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">        <span class="built_in">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);  </span><br><span class="line">       </span><br><span class="line">        GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0 ;  </span><br><span class="line">        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; <span class="comment">//PA0 ÊäÈë  </span></span><br><span class="line">        <span class="built_in">GPIO_Init</span>(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">        <span class="built_in">GPIO_ResetBits</span>(GPIOA,GPIO_Pin_0);                                               </span><br><span class="line">        TIM_TimeBaseStructure.TIM_Period = arr;</span><br><span class="line">        TIM_TimeBaseStructure.TIM_Prescaler =psc;          </span><br><span class="line">        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line">        <span class="built_in">TIM_TimeBaseInit</span>(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class="line">          TIM2_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">          TIM2_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">          TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">          TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;         </span><br><span class="line">          TIM2_ICInitStructure.TIM_ICFilter =<span class="number">0x00</span>;</span><br><span class="line">          <span class="built_in">TIM_ICInit</span>(TIM2, &amp;TIM2_ICInitStructure);</span><br><span class="line">        NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;          NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;  </span><br><span class="line">        NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;  </span><br><span class="line">        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">        <span class="built_in">NVIC_Init</span>(&amp;NVIC_InitStructure);  </span><br><span class="line">        <span class="built_in">TIM_ITConfig</span>(TIM2,TIM_IT_Update|TIM_IT_CC1,ENABLE);<span class="comment">//ÔÊÐí¸üÐ</span></span><br><span class="line">        <span class="built_in">TIM_Cmd</span>(TIM2,ENABLE );          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">       定时器2中断服务程序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;                     </span><br><span class="line"><span class="keyword">if</span>((TIM2CH1_CAPTURE_STA&amp;<span class="number">0X80</span>)==<span class="number">0</span>)</span><br><span class="line">                &#123;       </span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">TIM_GetITStatus</span>(TIM2, TIM_IT_Update) != RESET)</span><br><span class="line">                        &#123;            </span><br><span class="line">                                <span class="keyword">if</span>(TIM2CH1_CAPTURE_STA&amp;<span class="number">0X40</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>((TIM2CH1_CAPTURE_STA&amp;<span class="number">0X3F</span>)==<span class="number">0X3F</span>)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                TIM2CH1_CAPTURE_STA|=<span class="number">0X80</span>;</span><br><span class="line">                                                TIM2CH1_CAPTURE_VAL=<span class="number">0XFFFF</span>;</span><br><span class="line">                                        &#125;<span class="keyword">else</span> TIM2CH1_CAPTURE_STA++;</span><br><span class="line">                                &#125;         </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">TIM_GetITStatus</span>(TIM2, TIM_IT_CC1) !=</span><br><span class="line">                        &#123;       </span><br><span class="line">                                <span class="keyword">if</span>(TIM2CH1_CAPTURE_STA&amp;<span class="number">0X40</span>)               </span><br><span class="line">                             &#123;                                 </span><br><span class="line">                                TIM2CH1_CAPTURE_STA|=<span class="number">0X80</span>;               </span><br><span class="line">                                 TIM2CH1_CAPTURE_VAL=<span class="built_in">TIM_GetCapture1</span>(TIM2);</span><br><span class="line">                                                         <span class="built_in">TIM_OC1PolarityConfig</span>(TIM2,TIM_ICPolarity_Rising);  </span><br><span class="line">                                &#125;<span class="keyword">else</span>                                                         </span><br><span class="line">                                &#123;</span><br><span class="line">                                        TIM2CH1_CAPTURE_STA=<span class="number">0</span>;               </span><br><span class="line">                                        TIM2CH1_CAPTURE_VAL=<span class="number">0</span>;</span><br><span class="line">                                        TIM2CH1_CAPTURE_STA|=<span class="number">0X40</span>;       </span><br><span class="line">                                         <span class="built_in">TIM_SetCounter</span>(TIM2,<span class="number">0</span>);</span><br><span class="line">                                         <span class="built_in">TIM_OC1PolarityConfig</span>(TIM2,TIM_ICPolarity_Falling);               </span><br><span class="line">                                &#125;                    </span><br><span class="line">                        &#125;                                                                                   </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">                <span class="built_in">TIM_ClearITPendingBit</span>(TIM2, TIM_IT_CC1|TIM_IT_Update);</span><br><span class="line">                <span class="built_in">TIM2_1CAP</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment">       距离转化函数</span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">TIM2_1CAP</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(TIM2CH1_CAPTURE_STA&amp;<span class="number">0X80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    temp=TIM2CH1_CAPTURE_STA&amp;<span class="number">0X3F</span>;</span><br><span class="line">    temp*=<span class="number">65536</span>;</span><br><span class="line">    temp+=TIM2CH1_CAPTURE_VAL;</span><br><span class="line">    temp=temp*<span class="number">17</span>;</span><br><span class="line">    z=temp/<span class="number">1000</span>;</span><br><span class="line">    TIM2CH1_CAPTURE_STA=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>13.硬件材料<br><img src="./17.jpg" alt="Alt text"><br><img src="./18.jpg" alt="Alt text"><br><img src="./19.jpg" alt="Alt text"><br><img src="./20.jpg" alt="Alt text"></li><li>14.硬件部分介绍完毕，程序部分也穿插在其中一并说了。现在，来看下onenet web应用部分，具体onenet web应用部分如何设计，我就不在多说，论坛里都能找到，我只说论坛里没用的<br><img src="./21.png" alt="Alt text"><br>本次设计用stm32f103接入onenet  EDP服务器 和第三方服务器，这是结构简图：<br><img src="./22.png" alt="Alt text"><br>这是室内可燃气体泄露触发的报警：<br><img src="./23.png" alt="Alt text"><br>这是获取第三方网站本地气象数据效果：<br><img src="./24.jpg" alt="Alt text"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Onenet </tag>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[EDP] onenet智能热水循环泵</title>
      <link href="/2017/06/11/onenet-edp/"/>
      <url>/2017/06/11/onenet-edp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="EDP-onenet智能热水循环泵"><a href="#EDP-onenet智能热水循环泵" class="headerlink" title="[EDP] onenet智能热水循环泵"></a>[EDP] onenet智能热水循环泵</h3><blockquote><p>主要是基于cortex——M3 stm32f103c8t6芯片的物联网 智能热水循环泵【大二学生，不喜勿喷，大神路过求指点】为啥每次都做热水循环系统，因为此次分享，主要是为了升级去年基于51单片机以及2272模块的无线温控时控系统，51系统在工作的3个月内，参与测试的用户反应，温控对于热水泵的运行效果有些鸡肋，热水泵出水口的温度过高，18B20单测点不能科学的反映室内温度，增加测温点显然对于个体用户来说成本过大，布线麻烦（18B20走线越长，信号越弱）。齐次，2272超再生传输距离太短，虽然第二次升级改用超外差模块传输，但是距离也没改善多少，穿墙效果太差。后续有考虑到用CC1000,穿墙王，lora,等进行改善，但成本大，功耗大，而且需要成对模组，单独控制电路。果断放弃了。 此次用8266WIFI模块，将控制器的数据打包发送到云服务器，再由云服务器下发到手机，通过手机进行控制。 用到的材料：5*7的洞洞板<br><img src="./1.jpg" alt="Alt text"><br>主控仍然是stm32f103c8t6最小系统。<br><img src="./2.jpg" alt="Alt text"><br>为了做这个项目在淘宝买了8个最小系统板，结果有5个怎么也下载不进去东西，鼓捣了半天 才想到可能有写保护。第一次在淘宝买系统板遇见出厂带写保护的 浪费了半天时间解除保护,焊上数码管，蜂鸣器，继电器，按键。wifie用esp8266模块。<br><img src="./5.jpg" alt="Alt text"></p></blockquote><h4 id="移植麒麟miniv1-2-EDP的onenet源码"><a href="#移植麒麟miniv1-2-EDP的onenet源码" class="headerlink" title="移植麒麟miniv1.2 EDP的onenet源码"></a>移植麒麟miniv1.2 EDP的onenet源码</h4><blockquote><p>添加数码管驱动功能，dth11测温功能，按键功能（发现麒麟1.2版本的按键程序存在问题，并不能满足需求。自己改进了下）<br>GPIO接口根据自己硬件修改下后，就是主要改这个函数了，不知到源码是怎么实现单击，双击，和长按的。可能我下载到假源码了。这是我修改后的。其实就是把else语句去掉，还有无用的标志位。如果不去掉else内容  程序会在下面的按键功能函数里死掉.<br><img src="./11.png" alt="Alt text"><br><img src="./12.png" alt="Alt text"><br><img src="./13.png" alt="Alt text"><br><img src="./14.png" alt="Alt text"><br>可能看不清，看前面行序号，能大概知道用的switch语句，配合while死循环，来实现按键连按的。if语句加上break用了跳出死循环while(1)<br>数码管的源码很简单，贴一部分就不贴了，就是把温度，湿度，延时开，延时关。分开做了4个显示函数。用了显示特定状态下的模式字符。用来辨别。【数码管的动态扫描，在定时器中断里完成】<br><img src="./15.png" alt="Alt text"><br><img src="./16.png" alt="Alt text"><br>dth11驱动源码由于时间问题就不贴了，网上有很多源码，移植过来用就好了。<br>程序完成后，就开始做onenet界面<br><img src="./17.png" alt="Alt text"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Onenet </tag>
            
            <tag> EDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
